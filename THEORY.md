# AXOL Theoretical Foundation

## 0. 문서 목적

이 문서는 AXOL 언어의 이론적 토대를 정의한다.
AXOL은 기존 프로그래밍 패러다임의 세 가지 근본 전제를 부정하고,
양자역학적 모델에 기반한 새로운 연산 패러다임을 제안한다.

---

## 1. 출발점: 시간축으로부터의 해방

### 1.1 기존 언어의 근본 전제

모든 현대 프로그래밍 언어는 **시간축(sequential execution)** 을 근본 전제로 한다.

- **명령형**(C, Python): "이것을 먼저, 다음 저것을" — 명시적 시간 순서
- **함수형**(Haskell, Lisp): 선언적이나 평가 순서가 존재
- **병렬/비동기**(Go, Rust async): 여러 시간축을 동시에 돌릴 뿐, 시간축 자체를 벗어나지 않음
- **선언적**(SQL, HTML): "무엇"을 기술하지만, 실행 엔진이 시간축 위에서 처리

이는 폰 노이만 아키텍처가 클럭 사이클이라는 시간축 위에서 동작하기 때문이다.

### 1.2 AXOL의 전제

AXOL은 시간축이 아닌 **공간축(관계)** 과 **확률축(가능성)** 을 연산의 기반으로 삼는다.

```
기존 언어:  시간축  → instruction 1 → instruction 2 → instruction 3

AXOL:
  [공간축]  노드A ──관계── 노드B    → "어디에" 있는가가 연산을 결정
  [확률축]  상태 = { α|가능성1⟩ + β|가능성2⟩ }  → "얼마나 가능한가"가 연산을 결정
```

---

## 2. 핵심 모델: 얽힘 기반 연산

### 2.1 가정

> 양자 얽힘에 의해 시간과 독립적인 공간적 수행이 가능하다.
> 즉, 시간에 의한 병목을 제거할 수 있다.

단, 완전한 독립은 아니다.
**로직의 중첩(양자 얽힘의 매개체)** 이 구축된 상태에서,
주어진 값의 **관측(인자의 대입)** 이 이루어지면 즉각 output이 산출된다.

### 2.2 2단계 실행 모델

```
[Phase 1: 얽힘(Entanglement)]
  로직들이 중첩 상태로 연결됨
  시간 비용은 이 단계에서 지불

[Phase 2: 관측(Observation)]
  인자 대입 → 확률적으로 가장 가능성 높은 값으로 즉각 붕괴
  시간 병목 없음
```

### 2.3 기존 컴파일-실행과의 근본적 차이

|          | 기존 컴파일      | AXOL 얽힘                        |
|----------|-----------------|----------------------------------|
| 사전 준비 | 코드 → 기계어 번역 | 로직 간 확률적 상관관계를 구축         |
| 수행 시   | 기계어를 **순차 실행** | 관측(입력)으로 **즉각 붕괴**        |
| 병목     | 실행 경로 길이에 비례 | 얽힘 깊이에만 의존                 |
| 비유     | 빠르게 달릴 수 있는 길을 만듦 | 이미 도착해 있는 상태를 만듦       |

---

## 3. 확률적 결과 모델

### 3.1 핵심 전환

AXOL의 관측 결과는 정확한 값이 아니라 **확률이 높은 값**이다.

```
기존:    input → 정확한 output (100%)
AXOL:    input → 확률이 높은 output + 품질 지표
```

이 전환에 의해 지수적 폭발 문제가 해소된다.

- 정확한 값을 내려면: 모든 경로를 완전히 얽어야 함 → 2^n 비용 → 비현실적
- 확률적 값을 내려면: "충분히" 얽으면 됨 → 비용 조절 가능

**시간 병목을 없앤 대가로 정확성을 트레이드오프한다.**

```
정확도 ↑  →  얽힘 비용 ↑  →  구축 시간 ↑
정확도 ↓  →  얽힘 비용 ↓  →  구축 시간 ↓
             but 관측은 항상 즉각적
```

### 3.2 기존 확률적 언어와의 차이

|            | 기존 언어 | 확률적 언어(Stan 등) | AXOL                        |
|------------|----------|--------------------|-----------------------------|
| 실행       | 순차적 계산 | 샘플링 반복          | 얽힘 → 즉각 관측              |
| 결과       | 정확한 값   | 사후 분포            | 값 + 품질 지표(Ω, Φ)        |
| 비용 조절   | 불가       | 샘플 수로 조절       | **얽힘 깊이로 조절**           |
| 핵심 차이   | —         | 실행할 때마다 비용    | **얽힘은 한 번, 관측은 무한 번** |

---

## 4. 품질 척도: 결속도(Ω)와 선명도(Φ)

### 4.1 단일 확률의 한계

단순 확률(0~1)은 "맞을 가능성"만 표현한다. AXOL의 얽힘 모델에서는 부족하다.

```
상황 A: 확률 90%, 관측할 때마다 결과가 흔들림
상황 B: 확률 90%, 관측할 때마다 같은 결과
→ 둘 다 "90%"이지만 품질이 완전히 다름
```

### 4.2 2축 척도 정의

#### 결속도 (Cohesion, `Ω`)

> 얽힘이 얼마나 단단한가 — 붕괴의 **안정성**

```
Ω → 1.0: 관측할 때마다 같은 결과 (강한 얽힘)
Ω → 0.0: 관측할 때마다 다른 결과 (약한 얽힘, 거의 무작위)
```

#### 선명도 (Clarity, `Φ`)

> 붕괴된 값이 얼마나 좁은 범위에 있는가 — 출력의 **정밀도**

```
Φ → 1.0: "정확히 42" (점 하나로 수렴)
Φ → 0.0: "0~100 사이 어딘가" (넓은 분포)
```

### 4.3 2축 공간

```
        Φ (선명도)
        ↑
   1.0  │  ③ 날카롭지만       ① 이상적
        │    불안정              (강한 얽힘, 정밀한 출력)
        │
   0.0  │  ④ 무의미           ② 안정적이지만
        │    (노이즈)            흐릿함
        └──────────────────→ Ω (결속도)
       0.0                  1.0
```

| 영역 | Ω    | Φ    | 의미                          | 예시                    |
|------|------|------|------------------------------|------------------------|
| ①   | 높음 | 높음 | 강하게 얽혀있고 결과도 정밀        | 잘 구축된 수치 연산        |
| ②   | 높음 | 낮음 | 매번 같은 결과이나 범위가 넓음     | 분류(범주형 출력)          |
| ③   | 낮음 | 높음 | 정밀하지만 매번 다른 값           | 얽힘 부족, 추가 구축 필요   |
| ④   | 낮음 | 낮음 | 쓸모없음                       | 얽힘 실패                |

### 4.4 전통적 확률과의 관계

전통적 확률 P를 원한다면 두 축의 조합으로 유도 가능:

```
P ≈ Ω × Φ    (단순화)
```

단, P만으로는 역으로 Ω와 Φ를 분리할 수 없다.
AXOL의 2축 척도가 더 많은 정보를 담고 있다.

---

## 5. 자동 조절 직조기 (Auto-tuning Weaver)

### 5.1 원리

프로그래머는 **원하는 품질(Ω, Φ)만 선언**하고,
시스템이 **필요한 얽힘 비용을 자동으로 산출/분배**한다.

```
프로그래머: "이 정도 품질이면 돼"  →  Ω, Φ 목표 지정
시스템:     "그러면 이만큼 얽어야 해"  →  얽힘 비용(E) 산출
```

### 5.2 얽힘 비용 (Entanglement Cost, `E`)

```
E = f(로직 복잡도, 목표 Ω, 목표 Φ)
```

E는 구축 시 지불하는 시간/공간 비용이다.

```
                E (얽힘 비용)
                ↑
                │          ╱ Ω=0.99, Φ=0.99  (거의 정확 — 비쌈)
                │        ╱
                │      ╱
                │    ╱
                │  ╱  Ω=0.8, Φ=0.7  (대충 맞음 — 쌈)
                │╱
                └──────────────→ 로직 복잡도
```

### 5.3 직조기 동작 과정

```
[1] 로직 그래프 분석
    선언을 파싱 → 노드(연산)와 간선(의존관계) 추출

[2] 비용 산출
    목표 (Ω, Φ) + 그래프 구조 → 필요한 E 계산

[3] 예산 분배
    핵심 경로: 높은 얽힘 예산 할당
    주변 경로: 낮은 얽힘 예산 할당
    → 같은 E 안에서 품질 최대화

[4] 얽힘 맵(tapestry) 생성
    예산에 따라 실제 상관관계 구축

[5] 품질 보고
    예상 Ω, Φ를 프로그래머에게 반환
    목표 달성 불가 시 경고 및 대안 제안
```

### 5.4 예산 분배 전략

동일한 E 예산 안에서 모든 노드에 균등 분배하지 않는다.
핵심 경로에 집중 투자하고 주변 경로는 최소화한다.

```
예시: 3단계 파이프라인, 총 E = 200

  step1 (단순 변환):   E = 30   (15%)  ← 적게 얽어도 충분
  step2 (핵심 분석):   E = 120  (60%)  ← 집중 투자
  step3 (출력 포맷):   E = 50   (25%)  ← 중간
```

### 5.5 달성 불가능 감지

로직 구조상 목표 Ω, Φ에 도달할 수 없는 경우, 직조기가 이를 감지하고 보고한다.

```
> weave predict_weather: WARNING
>   target:   Ω(0.99) Φ(0.99)
>   maximum:  Ω(0.71) Φ(0.68)  ← 로직 구조상 한계
>   reason:   chaotic dependency detected
>   suggest:  lower target to Ω(0.7) Φ(0.7) or simplify logic
```

이는 기존 언어에서는 불가능한 피드백이다.
"이 로직은 본질적으로 불확실하다"는 정보를 컴파일 타임에 제공한다.

---

## 6. 새로운 패러다임: Declare → Weave → Observe

### 6.1 세 가지 근본 전제의 부정

AXOL은 프로그래밍의 세 가지 근본 전제를 동시에 부정한다.

| 기존 전제                        | AXOL                         |
|---------------------------------|------------------------------|
| 프로그램은 명령의 나열이다          | 프로그램은 **관계의 선언**이다    |
| 컴파일은 번역이다                 | 컴파일은 **직조(weaving)**다    |
| 실행은 순차적 처리다               | 실행은 **관측(observation)**이다 |

### 6.2 용어 체계

| 기존 용어    | AXOL 용어                | 의미                           |
|-------------|-------------------------|-------------------------------|
| compile     | **weave** (직조)         | 로직 간 얽힘 상관관계를 구축       |
| compiler    | **weaver** (직조기)      | 얽힘 맵을 자동 구축하는 시스템     |
| binary      | **tapestry** (직물)      | 구축된 얽힘 맵                  |
| execute     | **observe** (관측)       | 입력을 넣어 결과를 붕괴시킴       |
| runtime     | **observatory** (관측소)  | 관측을 수행하는 환경             |

### 6.3 흐름 비교

```
[기존]
  Write    →  Compile  →  Execute
  코드 작성     번역       순차 실행
  명령 나열   → 기계어   → 시간축 위에서 하나씩

[AXOL]
  Declare  →  Weave    →  Observe
  관계 선언     직조       관측
  구조 기술   → 얽힘 맵  → 즉각 붕괴
```

세 단계 모두 기존 개념과 1:1 대응이 되지 않는다.

| 단계 | 기존                | AXOL                 | 차이                    |
|------|--------------------|-----------------------|------------------------|
| 1    | 코드 작성 (명령 나열)  | 관계 선언 (구조 기술)    | 순서 없음               |
| 2    | 컴파일 (번역)        | 직조 (상관관계 구축)     | 명령어 생성이 아님        |
| 3    | 실행 (순차 처리)      | 관측 (즉각 붕괴)        | 시간축 없음              |

---

## 7. 코드 예시 (개념적)

### 7.1 기본: 얽힘 선언과 관측

```
// 직조: 로직 간 관계를 선언하고 품질 목표 지정
entangle search(query, database) @ Ω(0.9) Φ(0.7) {
    relevance ⟨∝⟩ similarity(query, database)
    ranking   ⟨∝⟩ relevance × recency
}

// 관측: 인자 대입 → 즉각 결과
result = observe search("AXOL", db)
// → { value: [...결과들...], Ω: 0.91, Φ: 0.73 }
```

### 7.2 수치 연산: 선명도 중시

```
entangle calculate(a, b) @ Ω(0.8) Φ(0.99) {
    result ⟨∝⟩ a ⟨+⟩ b
}

result = observe calculate(2, 3)
// → { value: 5.0, Ω: 0.82, Φ: 0.997 }
```

### 7.3 분류: 결속도 중시

```
entangle classify(image) @ Ω(0.9) Φ(0.6) {
    category ⟨∝⟩ features(image)
}

result = observe classify(photo)
// → { value: "고양이", Ω: 0.93, Φ: 0.58 }
```

### 7.4 신뢰도 부족 시 재관측

```
result = observe search("AXOL", db)

if result.Ω < 0.95 {
    result = reobserve search("AXOL", db) × 10
    // 10회 관측 → 분포 수렴 → Ω 상승
}
```

### 7.5 직조 결과 리포트

```
> weave search: complete
>   target:   Ω(0.9)  Φ(0.7)
>   actual:   Ω(0.91) Φ(0.73)
>   cost:     E = 342
>   nodes:    2 (relevance, ranking)
>   depth:    4 layers
```

---

## 8. 미해결 과제

아직 정의되지 않았거나 추가 논의가 필요한 항목:

| 과제                             | 설명                                           |
|----------------------------------|-----------------------------------------------|
| Ω, Φ의 정확한 수학적 정의           | 0~1 범위인지, 다른 스케일이 자연스러운지             |
| 관측 후 얽힘 상태의 보존 여부        | 관측이 얽힘을 소모하는지, 보존하는지                 |
| E의 구체적 산출 공식               | 로직 복잡도를 어떻게 정량화하는지                    |
| 얽힘 맵(tapestry)의 내부 자료구조   | 클래식 하드웨어에서의 표현 방식                     |
| 중첩 단위                         | 무엇이 중첩되는가 — 값, 함수, 모듈                 |
| 얽힘 선언 문법의 형식화             | `⟨∝⟩`, `⟨+⟩`, `⟨⊗⟩` 등의 정확한 의미론           |
| 게으른 얽힘(lazy entanglement)     | 관측 경로에 필요한 것만 구축하는 최적화 전략          |
| 얽힘 범위 제한                     | 전역 vs 로컬 얽힘 클러스터 관리                    |
| 관측의 부작용(side effect) 모델     | 관측이 외부 세계에 영향을 줄 때의 처리               |

---

## 9. 요약

AXOL은 다음을 주장한다:

1. **프로그래밍의 기본 축을 시간에서 공간/확률로 전환할 수 있다.**
2. **로직의 얽힘을 사전에 구축하면, 관측(입력) 시 즉각적 결과를 얻는다.**
3. **정확성 대신 확률을 수용함으로써, 지수적 폭발 없이 이 모델이 현실화된다.**
4. **결과의 품질은 결속도(Ω)와 선명도(Φ)라는 2축 고유 척도로 표현된다.**
5. **직조기(weaver)가 목표 품질에 맞게 얽힘 비용을 자동 산출/분배한다.**
6. **이는 번역(compile)→실행(execute)이 아닌, 직조(weave)→관측(observe)이라는 새로운 패러다임이다.**
