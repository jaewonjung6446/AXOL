# AXOL Theoretical Foundation

## 0. 문서 목적

이 문서는 AXOL 언어의 이론적 토대를 정의한다.
AXOL은 기존 프로그래밍 패러다임의 세 가지 근본 전제를 부정하고,
양자역학적 모델에 기반한 새로운 연산 패러다임을 제안한다.

---

## 1. 출발점: 시간축으로부터의 해방

### 1.1 기존 언어의 근본 전제

모든 현대 프로그래밍 언어는 **시간축(sequential execution)** 을 근본 전제로 한다.

- **명령형**(C, Python): "이것을 먼저, 다음 저것을" — 명시적 시간 순서
- **함수형**(Haskell, Lisp): 선언적이나 평가 순서가 존재
- **병렬/비동기**(Go, Rust async): 여러 시간축을 동시에 돌릴 뿐, 시간축 자체를 벗어나지 않음
- **선언적**(SQL, HTML): "무엇"을 기술하지만, 실행 엔진이 시간축 위에서 처리

이는 폰 노이만 아키텍처가 클럭 사이클이라는 시간축 위에서 동작하기 때문이다.

### 1.2 AXOL의 전제

AXOL은 시간축이 아닌 **공간축(관계)** 과 **확률축(가능성)** 을 연산의 기반으로 삼는다.

핵심 이점은 관측(observe) 비용이 **파이프라인 깊이에 무관**하다는 것이다.
단, 차원에 대해서는 O(dim²) 스케일링이 존재한다 — 차원이 커지면 관측 비용도 증가한다.

```
기존 언어:  시간축  → instruction 1 → instruction 2 → instruction 3

AXOL:
  [공간축]  노드A ──관계── 노드B    → "어디에" 있는가가 연산을 결정
  [확률축]  상태 = { α|가능성1⟩ + β|가능성2⟩ }  → "얼마나 가능한가"가 연산을 결정
```

---

## 2. 핵심 모델: 얽힘 기반 연산

### 2.1 가정

> 양자 얽힘에 의해 시간과 독립적인 공간적 수행이 가능하다.
> 즉, 시간에 의한 병목을 제거할 수 있다.

단, 완전한 독립은 아니다.
**로직의 중첩(양자 얽힘의 매개체)** 이 구축된 상태에서,
주어진 값의 **관측(인자의 대입)** 이 이루어지면 즉각 output이 산출된다.

### 2.2 2단계 실행 모델

```
[Phase 1: 얽힘(Entanglement)]
  로직들이 중첩 상태로 연결됨
  시간 비용은 이 단계에서 지불

[Phase 2: 관측(Observation)]
  인자 대입 → 확률적으로 가장 가능성 높은 값으로 즉각 붕괴
  시간 병목 없음
```

### 2.3 기존 컴파일-실행과의 근본적 차이

|          | 기존 컴파일      | AXOL 얽힘                        |
|----------|-----------------|----------------------------------|
| 사전 준비 | 코드 → 기계어 번역 | 로직 간 확률적 상관관계를 구축         |
| 수행 시   | 기계어를 **순차 실행** | 관측(입력)으로 **즉각 붕괴**        |
| 병목     | 실행 경로 길이에 비례 | 얽힘 깊이에만 의존                 |
| 비유     | 빠르게 달릴 수 있는 길을 만듦 | 이미 도착해 있는 상태를 만듦       |

---

## 3. 확률적 결과 모델

### 3.1 핵심 전환

AXOL의 관측 결과는 정확한 값이 아니라 **확률이 높은 값**이다.

```
기존:    input → 정확한 output (100%)
AXOL:    input → 확률이 높은 output + 품질 지표
```

이 전환에 의해 지수적 폭발 문제가 해소된다.

- 정확한 값을 내려면: 모든 경로를 완전히 얽어야 함 → 2^n 비용 → 비현실적
- 확률적 값을 내려면: "충분히" 얽으면 됨 → 비용 조절 가능

**시간 병목을 없앤 대가로 정확성을 트레이드오프한다.**

```
정확도 ↑  →  얽힘 비용 ↑  →  구축 시간 ↑
정확도 ↓  →  얽힘 비용 ↓  →  구축 시간 ↓
             but 관측은 항상 즉각적
```

### 3.2 기존 확률적 언어와의 차이

|            | 기존 언어 | 확률적 언어(Stan 등) | AXOL                        |
|------------|----------|--------------------|-----------------------------|
| 실행       | 순차적 계산 | 샘플링 반복          | 얽힘 → 즉각 관측              |
| 결과       | 정확한 값   | 사후 분포            | 값 + 품질 지표(Ω, Φ)        |
| 비용 조절   | 불가       | 샘플 수로 조절       | **얽힘 깊이로 조절**           |
| 핵심 차이   | —         | 실행할 때마다 비용    | **얽힘은 한 번, 관측은 무한 번** |

---

## 4. 품질 척도: 결속도(Ω)와 선명도(Φ)

### 4.1 단일 확률의 한계

단순 확률(0~1)은 "맞을 가능성"만 표현한다. AXOL의 얽힘 모델에서는 부족하다.

```
상황 A: 확률 90%, 관측할 때마다 결과가 흔들림
상황 B: 확률 90%, 관측할 때마다 같은 결과
→ 둘 다 "90%"이지만 품질이 완전히 다름
```

### 4.2 2축 척도 정의

#### 결속도 (Cohesion, `Ω`)

> 얽힘이 얼마나 단단한가 — 붕괴의 **안정성**

```
Ω → 1.0: 관측할 때마다 같은 결과 (강한 얽힘)
Ω → 0.0: 관측할 때마다 다른 결과 (약한 얽힘, 거의 무작위)
```

#### 선명도 (Clarity, `Φ`)

> 붕괴된 값이 얼마나 좁은 범위에 있는가 — 출력의 **정밀도**

```
Φ → 1.0: "정확히 42" (점 하나로 수렴)
Φ → 0.0: "0~100 사이 어딘가" (넓은 분포)
```

### 4.3 2축 공간

```
        Φ (선명도)
        ↑
   1.0  │  ③ 날카롭지만       ① 이상적
        │    불안정              (강한 얽힘, 정밀한 출력)
        │
   0.0  │  ④ 무의미           ② 안정적이지만
        │    (노이즈)            흐릿함
        └──────────────────→ Ω (결속도)
       0.0                  1.0
```

| 영역 | Ω    | Φ    | 의미                          | 예시                    |
|------|------|------|------------------------------|------------------------|
| ①   | 높음 | 높음 | 강하게 얽혀있고 결과도 정밀        | 잘 구축된 수치 연산        |
| ②   | 높음 | 낮음 | 매번 같은 결과이나 범위가 넓음     | 분류(범주형 출력)          |
| ③   | 낮음 | 높음 | 정밀하지만 매번 다른 값           | 얽힘 부족, 추가 구축 필요   |
| ④   | 낮음 | 낮음 | 쓸모없음                       | 얽힘 실패                |

### 4.4 전통적 확률과의 관계

전통적 확률 P를 원한다면 두 축의 조합으로 유도 가능:

```
P ≈ Ω × Φ    (단순화)
```

단, P만으로는 역으로 Ω와 Φ를 분리할 수 없다.
AXOL의 2축 척도가 더 많은 정보를 담고 있다.

---

## 5. 자동 조절 직조기 (Auto-tuning Weaver)

### 5.1 원리

프로그래머는 **원하는 품질(Ω, Φ)만 선언**하고,
시스템이 **필요한 얽힘 비용을 자동으로 산출/분배**한다.

```
프로그래머: "이 정도 품질이면 돼"  →  Ω, Φ 목표 지정
시스템:     "그러면 이만큼 얽어야 해"  →  얽힘 비용(E) 산출
```

### 5.2 얽힘 비용 (Entanglement Cost, `E`)

```
E = f(로직 복잡도, 목표 Ω, 목표 Φ)
```

E는 구축 시 지불하는 시간/공간 비용이다.

```
                E (얽힘 비용)
                ↑
                │          ╱ Ω=0.99, Φ=0.99  (거의 정확 — 비쌈)
                │        ╱
                │      ╱
                │    ╱
                │  ╱  Ω=0.8, Φ=0.7  (대충 맞음 — 쌈)
                │╱
                └──────────────→ 로직 복잡도
```

### 5.3 직조기 동작 과정

```
[1] 로직 그래프 분석
    선언을 파싱 → 노드(연산)와 간선(의존관계) 추출

[2] 비용 산출
    목표 (Ω, Φ) + 그래프 구조 → 필요한 E 계산

[3] 예산 분배
    핵심 경로: 높은 얽힘 예산 할당
    주변 경로: 낮은 얽힘 예산 할당
    → 같은 E 안에서 품질 최대화

[4] 얽힘 맵(tapestry) 생성
    예산에 따라 실제 상관관계 구축

[5] 품질 보고
    예상 Ω, Φ를 프로그래머에게 반환
    목표 달성 불가 시 경고 및 대안 제안
```

### 5.4 예산 분배 전략

동일한 E 예산 안에서 모든 노드에 균등 분배하지 않는다.
핵심 경로에 집중 투자하고 주변 경로는 최소화한다.

```
예시: 3단계 파이프라인, 총 E = 200

  step1 (단순 변환):   E = 30   (15%)  ← 적게 얽어도 충분
  step2 (핵심 분석):   E = 120  (60%)  ← 집중 투자
  step3 (출력 포맷):   E = 50   (25%)  ← 중간
```

### 5.5 달성 불가능 감지

로직 구조상 목표 Ω, Φ에 도달할 수 없는 경우, 직조기가 이를 감지하고 보고한다.

```
> weave predict_weather: WARNING
>   target:   Ω(0.99) Φ(0.99)
>   maximum:  Ω(0.71) Φ(0.68)  ← 로직 구조상 한계
>   reason:   chaotic dependency detected
>   suggest:  lower target to Ω(0.7) Φ(0.7) or simplify logic
```

이는 기존 언어에서는 불가능한 피드백이다.
"이 로직은 본질적으로 불확실하다"는 정보를 컴파일 타임에 제공한다.

---

## 6. 새로운 패러다임: Declare → Weave → Observe

### 6.1 세 가지 근본 전제의 부정

AXOL은 프로그래밍의 세 가지 근본 전제를 동시에 부정한다.

| 기존 전제                        | AXOL                         |
|---------------------------------|------------------------------|
| 프로그램은 명령의 나열이다          | 프로그램은 **관계의 선언**이다    |
| 컴파일은 번역이다                 | 컴파일은 **직조(weaving)**다    |
| 실행은 순차적 처리다               | 실행은 **관측(observation)**이다 |

### 6.2 용어 체계

| 기존 용어    | AXOL 용어                | 의미                           |
|-------------|-------------------------|-------------------------------|
| compile     | **weave** (직조)         | 로직 간 얽힘 상관관계를 구축       |
| compiler    | **weaver** (직조기)      | 얽힘 맵을 자동 구축하는 시스템     |
| binary      | **tapestry** (직물)      | 구축된 얽힘 맵                  |
| execute     | **observe** (관측)       | 입력을 넣어 결과를 붕괴시킴       |
| runtime     | **observatory** (관측소)  | 관측을 수행하는 환경             |

### 6.3 흐름 비교

```
[기존]
  Write    →  Compile  →  Execute
  코드 작성     번역       순차 실행
  명령 나열   → 기계어   → 시간축 위에서 하나씩

[AXOL]
  Declare  →  Weave    →  Observe
  관계 선언     직조       관측
  구조 기술   → 얽힘 맵  → 즉각 붕괴
```

세 단계 모두 기존 개념과 1:1 대응이 되지 않는다.

| 단계 | 기존                | AXOL                 | 차이                    |
|------|--------------------|-----------------------|------------------------|
| 1    | 코드 작성 (명령 나열)  | 관계 선언 (구조 기술)    | 순서 없음               |
| 2    | 컴파일 (번역)        | 직조 (상관관계 구축)     | 명령어 생성이 아님        |
| 3    | 실행 (순차 처리)      | 관측 (즉각 붕괴)        | 시간축 없음              |

---

## 7. 코드 예시 (개념적)

### 7.1 기본: 얽힘 선언과 관측

```
// 직조: 로직 간 관계를 선언하고 품질 목표 지정
entangle search(query, database) @ Ω(0.9) Φ(0.7) {
    relevance ⟨∝⟩ similarity(query, database)
    ranking   ⟨∝⟩ relevance × recency
}

// 관측: 인자 대입 → 즉각 결과
result = observe search("AXOL", db)
// → { value: [...결과들...], Ω: 0.91, Φ: 0.73 }
```

### 7.2 수치 연산: 선명도 중시

```
entangle calculate(a, b) @ Ω(0.8) Φ(0.99) {
    result ⟨∝⟩ a ⟨+⟩ b
}

result = observe calculate(2, 3)
// → { value: 5.0, Ω: 0.82, Φ: 0.997 }
```

### 7.3 분류: 결속도 중시

```
entangle classify(image) @ Ω(0.9) Φ(0.6) {
    category ⟨∝⟩ features(image)
}

result = observe classify(photo)
// → { value: "고양이", Ω: 0.93, Φ: 0.58 }
```

### 7.4 신뢰도 부족 시 재관측

```
result = observe search("AXOL", db)

if result.Ω < 0.95 {
    result = reobserve search("AXOL", db) × 10
    // 10회 관측 → 분포 수렴 → Ω 상승
}
```

### 7.5 직조 결과 리포트

```
> weave search: complete
>   target:   Ω(0.9)  Φ(0.7)
>   actual:   Ω(0.91) Φ(0.73)
>   cost:     E = 342
>   nodes:    2 (relevance, ranking)
>   depth:    4 layers
```

---

## 8. 실증 검증: 극한 성능 벤치마크

### 8.1 실험 설계

AXOL의 핵심 주장 — "직조는 한 번, 관측은 즉각적" — 을 극한 조건에서 검증하였다.

4가지 실험을 수행하였으며, 각 실험은 기존 순차 실행(Traditional)과 AXOL의 두 가지 관측 방식(현재 구현 / 행렬 사전합성)을 비교한다.

| 실험 | 변수 | 범위 | 검증 대상 |
|------|------|------|----------|
| 1. 차원 스케일링 | dim | 4 → 4,096 | dim 증가 시 관측 비용 변화 |
| 2. 깊이 스케일링 | depth | 5 → 5,000 | 관측의 깊이 독립성 |
| 3. 반복 관측 상각 | count | 1 → 1,000,000 | 한계 비용 제로 수렴 |
| 4. 차원×깊이 복합 | dim×depth | (64,10)→(1024,100) | 복합 스케일링 |

### 8.2 핵심 결과

#### 실험 1: 관측 시간 vs 차원 (depth=1)

| Dimension | Traditional | AXOL Observe | 비율 |
|-----------|-------------|--------------|------|
| 4 | 17.9 μs | 24.3 μs | 0.7x |
| 64 | 13.4 μs | 18.1 μs | 0.7x |
| 256 | 53.8 μs | 25.0 μs | **2.2x** |
| 1,024 | 2,650 μs | 259 μs | **10.2x** |
| 4,096 | 39,503 μs | 2,616 μs | **15.1x** |

dim이 1024배(4→4096) 증가할 때 관측 시간은 107배 증가. **차원 독립성은 성립하지 않으며, O(dim²) 스케일링**을 보인다. 그러나 dim=4096에서도 **2.6ms** 수준이며, Traditional 대비 **15x 가속**은 유효하다.

#### 실험 2: 파이프라인 깊이 스케일링 (dim=16)

| Depth | Traditional | Composed Observe | 비율 |
|-------|-------------|------------------|------|
| 5 | 21.6 μs | 10.0 μs | 2x |
| 50 | 146.5 μs | 9.9 μs | 15x |
| 500 | 1,434 μs | 9.8 μs | 146x |
| 5,000 | 20,263 μs | **8.4 μs** | **2,412x** |

**핵심 발견:** Composed Observe(현재 observe()에 내장됨)는 depth=5000에서도 ~10μs로 **완벽한 수평선**을 그린다.
이는 §2.2의 "관측 시 시간 병목 없음" 주장 중 **깊이에 대한 독립성**을 실증적으로 증명한다.
단, 이 결과는 선형 체인(TransformOp만으로 구성된 파이프라인)에 한정되며, 차원에 대해서는 O(dim²) 비용이 존재한다.

#### 실험 3: 반복 관측 상각 (dim=16, depth=100)

| 관측 횟수 | Traditional/회 | AXOL 상각/회 | 직조 상각 |
|-----------|---------------|-------------|----------|
| 1 | 355.6 μs | 738.8 ms | 738.2 ms |
| 1,000 | 355.6 μs | 1,304 μs | 738.2 μs |
| 100,000 | 355.6 μs | 573.8 μs | 7.4 μs |
| 1,000,000 | 355.6 μs | 567.1 μs | **0.7 μs** |

**핵심 발견:** 100만 회 관측 시 직조 상각 비용 = 0.7μs → **사실상 제로**.
§3.1의 "얽힘은 한 번, 관측은 무한 번" 주장을 수치적으로 검증.

#### 실험 4: 차원 × 깊이 복합 스케일링

| (dim, depth) | 복잡도 | Traditional | Composed | Speedup |
|--------------|--------|-------------|----------|---------|
| (64, 10) | 40,960 | 62.7 μs | 12.8 μs | **5x** |
| (256, 100) | 6.5M | 6.18 ms | 73.9 μs | **84x** |
| (512, 500) | 131M | 380.9 ms | 679.6 μs | **560x** |
| (1024, 100) | 105M | 277.3 ms | 2.68 ms | **104x** |

복잡도가 3,200배 증가할 때(40K→131M), Traditional은 6,075배 느려지지만 Composed는 53배만 증가.

### 8.3 복잡도 요약

```
기존 순차 실행:  cost_per_call = O(depth × dim²)     ← 매 호출마다 N단계 순차 실행
AXOL 직조:      cost_one_time = O(depth × dim³)     ← 1회 직조 (행렬 합성 + 품질 보증)
AXOL 관측:      cost_per_call = O(dim²)              ← depth 무관! 단일 행렬-벡터 곱
```

N회 관측 시 총 비용:
```
Traditional = N × O(depth × dim²)
AXOL        = O(depth × dim³) + N × O(dim²)

∴ N >> depth × dim 일 때, AXOL은 depth에 비례하여 가속.
  depth=5000에서 2,412x, (512,500)에서 560x 확인.
```

### 8.4 실험의 한계와 시사점

1. **"관측 비용 일정"의 정확한 의미**: observe()는 **파이프라인 깊이에 무관**하다 (행렬 사전합성으로 O(1) depth). 그러나 **차원에 대해서는 O(dim²)** 스케일링이 존재한다. "관측 비용이 일정하다"가 아니라 "관측 비용이 깊이에 무관하다"가 정확한 표현이다.
2. **선형 변환만 지원**: 현재의 행렬 사전합성(composed observe)은 TransformOp 체인(선형 변환)에만 적용된다. MergeOp, 비선형 연산, 분기가 포함된 파이프라인은 fallback 경로(순차 실행)를 사용한다. 이는 구조적 한계이다.
3. **dim=512 전환점**: dim ≤ 256에서는 AXOL 오버헤드가 우세하나, dim ≥ 512부터 AXOL이 역전. 이는 cache-friendly한 단일 행렬 연산 구조의 이점.
4. **직조 비용의 현실**: 극한 설정 (dim=4096, depth=1)에서 직조에 ~1분 이상 소요. 이는 §5의 "비용은 구축 시 지불" 원칙을 실증하되, 대규모 시스템에서의 직조 최적화가 추후 과제.
5. **정확도**: Composed observe의 결과는 Traditional 순차실행과 float32 정밀도 범위 내에서 일치한다 (Hellinger distance < 0.01). 행렬 곱 순서가 동일하므로 수치적 차이는 float64→float32 변환에서만 발생한다.

---

## 9. 미해결 과제

아직 정의되지 않았거나 추가 논의가 필요한 항목:

| 과제                             | 설명                                           |
|----------------------------------|-----------------------------------------------|
| Ω, Φ의 정확한 수학적 정의           | 0~1 범위인지, 다른 스케일이 자연스러운지             |
| 관측 후 얽힘 상태의 보존 여부        | 관측이 얽힘을 소모하는지, 보존하는지                 |
| E의 구체적 산출 공식               | 로직 복잡도를 어떻게 정량화하는지                    |
| 얽힘 맵(tapestry)의 내부 자료구조   | 클래식 하드웨어에서의 표현 방식                     |
| 중첩 단위                         | 무엇이 중첩되는가 — 값, 함수, 모듈                 |
| 얽힘 선언 문법의 형식화             | `⟨∝⟩`, `⟨+⟩`, `⟨⊗⟩` 등의 정확한 의미론           |
| 게으른 얽힘(lazy entanglement)     | 관측 경로에 필요한 것만 구축하는 최적화 전략          |
| 얽힘 범위 제한                     | 전역 vs 로컬 얽힘 클러스터 관리                    |
| 관측의 부작용(side effect) 모델     | 관측이 외부 세계에 영향을 줄 때의 처리               |

---

## 10. 요약

AXOL은 다음을 주장한다:

1. **프로그래밍의 기본 축을 시간에서 공간/확률로 전환할 수 있다.**
2. **로직의 얽힘을 사전에 구축하면, 관측(입력) 시 즉각적 결과를 얻는다.**
3. **정확성 대신 확률을 수용함으로써, 지수적 폭발 없이 이 모델이 현실화된다.**
4. **결과의 품질은 결속도(Ω)와 선명도(Φ)라는 2축 고유 척도로 표현된다.**
5. **직조기(weaver)가 목표 품질에 맞게 얽힘 비용을 자동 산출/분배한다.**
6. **이는 번역(compile)→실행(execute)이 아닌, 직조(weave)→관측(observe)이라는 새로운 패러다임이다.**
