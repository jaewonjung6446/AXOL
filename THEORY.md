# AXOL Theoretical Foundation

## 0. 문서 목적

이 문서는 AXOL 언어의 이론적 토대를 정의한다.
AXOL은 **카오스 이론(동역학계 이론)** 을 프로그래밍의 연산 모델과 품질 척도에 적용하여,
기존 컴파일-실행 패러다임과 구별되는 **Declare → Weave → Observe** 패러다임을 제안한다.

---

## 1. 출발점: 연산 비용의 재배치

### 1.1 기존 실행 모델의 병목

모든 현대 프로그래밍 언어의 실행 비용은 **호출 시점**에 집중된다.

```
기존 모델:  input → [step1 → step2 → ... → stepN] → output
                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     매 호출마다 N단계 순차 비용 발생
```

파이프라인 깊이(depth)가 깊어질수록 호출 비용은 선형으로 증가한다.
100단계 파이프라인을 1만 번 호출하면, 100만 단계를 순차 실행한다.

### 1.2 AXOL의 핵심 통찰: 비용의 시간적 분리

AXOL은 이 비용 구조를 **두 단계로 분리**한다.

```
AXOL:
  [Phase 1: 직조(Weave)]
    파이프라인의 모든 단계를 사전에 하나의 연산으로 합성
    시간/공간 비용은 이 단계에서 1회 지불

  [Phase 2: 관측(Observe)]
    입력을 합성된 연산에 통과 → 결과 산출
    파이프라인 깊이에 무관한 비용 — O(dim²)
```

이것은 비유가 아니라 수학적 사실이다.
N개의 행렬 M₁, M₂, ..., Mₙ을 사전에 합성하면 M_composed = M₁ × M₂ × ... × Mₙ이고,
관측 시에는 `input @ M_composed`라는 단일 행렬-벡터 곱만 수행한다.

**AXOL이 이 단순한 선형대수적 사실 위에 카오스 이론을 얹는 이유**는
합성된 연산의 **품질을 정량적으로 보장**하기 위해서다.
행렬 합성 자체는 누구나 할 수 있지만,
"이 합성 결과가 얼마나 안정적이고 정밀한가"를 Lyapunov 지수와 프랙탈 차원으로 측정하고 보증하는 것이 AXOL의 고유한 기여다.

### 1.3 기존 전처리 패턴과의 비교

| 기법 | 사전 비용 | 쿼리 비용 | 품질 보증 |
|------|----------|----------|----------|
| DB 인덱스 | 인덱스 구축 O(N log N) | 조회 O(log N) | 정확 (결정적) |
| ML 학습-추론 | 학습 O(epochs × data) | 추론 O(model) | 손실 함수로 간접 측정 |
| **AXOL 직조-관측** | 직조 O(depth × dim³) | 관측 O(dim²) | **Ω, Φ로 직접 보증** |

AXOL의 차별점은 "사전 구축 → 빠른 쿼리" 패턴 자체가 아니라,
**카오스 이론에 기반한 내장 품질 보증 체계**다.

---

## 2. 수학적 기반: 위상 공간과 끌개

### 2.1 위상 공간 (Phase Space)

AXOL 프로그램은 **위상 공간** R^n에서 동작한다.
n은 선언된 입출력의 차원에 의해 결정된다.
시스템의 상태는 이 공간의 벡터 `x ∈ R^n`이다.

```
선언:  search(query[16], database[16]) → ranking[16]
위상 공간:  R^16 (16차원 상태 공간)
```

### 2.2 궤적 행렬 (Trajectory Matrix)

선언된 관계는 위상 공간 위의 **동역학**으로 변환된다.

```
x_{k+1} = x_k @ M
```

행렬 M은 관계의 종류(RelationKind)에 따라 서로 다른 스펙트럼 특성을 갖도록 구축된다:

| 관계 종류 | 행렬 특성 | 동역학적 의미 |
|----------|----------|-------------|
| PROPORTIONAL (∝) | 항등 근방 섭동 | 수렴적 — 고정점 끌개 |
| ADDITIVE (+) | 직교 회전 + 수축 | 준안정 — 극한 순환 |
| MULTIPLICATIVE (×) | 행렬 곱 구조 | 잠재적 카오스 |
| INVERSE (!) | 역행렬 구조 | 큰 고윳값 — 발산 가능 |
| CONDITIONAL (?) | 블록 대각 | 조건부 분기 |

### 2.3 끌개 (Attractor)

직조 과정은 궤적 행렬로부터 **끌개(attractor)** 를 구축한다.

> 끌개 = 위상 공간의 콤팩트 부분집합 A로서:
> 1. 시스템 동역학 f 하에서 불변: f(A) = A
> 2. 영이 아닌 측도의 흡인 유역(basin of attraction) B(A)을 가짐
> 3. 초기 조건에 민감하게 의존 (카오스)
> 4. 비정수 (프랙탈) 차원을 가짐

AXOL에서 끌개는 직물(tapestry)의 핵심 자료구조다.
직물 = 끌개의 그래프 + 각 끌개의 Lyapunov/프랙탈 메트릭 + 사전합성 행렬.

### 2.4 간섭 층 (Interference Layers)

단순한 궤적 행렬만으로는 끌개 구조가 빈약하다.
직조기는 **Hadamard 기반 간섭 층**을 적용하여 끌개 구조를 풍부하게 한다.

```
각 간섭 층:  M' = Q @ M @ Q^T  (Q는 직교 행렬)
           → QR 정규화로 스펙트럼 반경 제어
           → 스펙트럼 반경 ≤ 0.95로 수축하여 안정성 유지
```

간섭 층의 수 = `ceil(log₂(budget / BASE_COST))`
높은 예산 → 더 많은 간섭 층 → 더 정교한 끌개 구조.

---

## 3. 품질 척도: 결속도(Ω)와 선명도(Φ)

### 3.1 단일 확률의 한계

단순 확률(0~1)은 "맞을 가능성"만 표현한다. 이것으로는 부족하다.

```
상황 A: 확률 90%, 관측할 때마다 결과가 흔들림
상황 B: 확률 90%, 관측할 때마다 같은 결과
→ 둘 다 "90%"이지만 품질이 완전히 다름
```

AXOL은 카오스 이론의 두 가지 정량적 척도를 사용하여 이 구별을 가능하게 한다.

### 3.2 결속도 (Cohesion, Ω) — Lyapunov 지수로부터

**최대 Lyapunov 지수** λ는 초기 조건에 대한 민감성을 정량화한다:

```
λ = lim_{k→∞} (1/k) × ln(‖δx_k‖ / ‖δx_0‖)
```

- λ < 0: 궤적이 수렴 (안정 고정점/순환)
- λ = 0: 중립 안정성 (극한 순환 경계)
- λ > 0: 궤적이 발산 (카오스)

**결속도(Ω)** 는 이 지수의 역변환이다:

```
Ω = 1 / (1 + max(λ, 0))
```

| λ | Ω | 의미 |
|---|---|-----|
| λ ≪ 0 | → 1.0 | 강한 수렴, 관측 결과가 매번 동일 |
| λ = 0 | = 1.0 | 한계 안정 |
| λ = 1 | = 0.5 | 중간 카오스 |
| λ → ∞ | → 0.0 | 완전 카오스, 관측 결과가 무작위 |

**추정 방법: Benettin의 QR 분해법**

```
1. 직교 정규 벡터 {e₁, ..., eₙ} 초기화
2. 각 시간 단계 k에 대해:
   a. 전파:   e_i' = M @ e_i
   b. QR 분해: [e₁'|...|eₙ'] = Q @ R
   c. 누적:   λ_i += ln(R_ii)
   d. 갱신:   e_i = column_i(Q)
3. λ_i = (1/K) × 누적_λ_i
```

**경험적 Ω** (반복 관측으로부터):

```
Ω_empirical = (최빈값이 argmax와 일치한 횟수) / 총 관측 횟수
```

### 3.3 선명도 (Clarity, Φ) — 프랙탈 차원으로부터

**프랙탈 차원** D는 끌개의 기하학적 복잡도를 정량화한다.

**박스 카운팅 차원:**

```
D = lim_{ε→0} ln(N(ε)) / ln(1/ε)
```

N(ε) = 끌개를 덮는 데 필요한 변 길이 ε인 박스의 수.

**상관 차원** (Grassberger-Procaccia):

```
C(r) = lim_{N→∞} (2 / N(N-1)) × Σ_{i<j} Θ(r - ‖x_i - x_j‖)
D_corr = lim_{r→0} ln(C(r)) / ln(r)
```

**선명도(Φ)** 는 프랙탈 차원의 역변환이다:

```
Φ = 1 / (1 + D / D_max)
```

D_max = n (위상 공간 차원).

| D | Φ | 의미 |
|---|---|-----|
| D = 0 (고정점) | = 1.0 | 완벽히 정밀 — 점 하나로 수렴 |
| D = D_max (공간 충전) | = 0.5 | 끌개가 전 공간에 분포 |
| D ≫ D_max | → 0.0 | 무의미 (이론적 극한) |

**엔트로피 기반 Φ** (확률 분포로부터의 근사):

```
H = -Σᵢ pᵢ ln(pᵢ)     (Shannon 엔트로피)
H_max = ln(n)
Φ_entropy = 1 - H / H_max
```

### 3.4 2축 품질 공간

```
        Φ (선명도)
        ↑
   1.0  │  ③ 정밀하지만         ① 이상적
        │    불안정               (수렴적 끌개, 정밀한 출력)
        │
   0.0  │  ④ 무의미             ② 안정적이지만
        │    (노이즈)              흐릿함
        └──────────────────→ Ω (결속도)
       0.0                  1.0
```

| 영역 | Ω | Φ | 동역학적 의미 | 예시 |
|------|---|---|-------------|-----|
| ① | 높음 | 높음 | λ < 0, D ≈ 0: 안정 고정점 끌개 | 잘 구축된 수치 연산 |
| ② | 높음 | 낮음 | λ < 0, D > 0: 안정하지만 넓은 끌개 | 분류 (범주형 출력) |
| ③ | 낮음 | 높음 | λ > 0, D ≈ 0: 불안정한 좁은 궤적 | 직조 부족, 추가 구축 필요 |
| ④ | 낮음 | 낮음 | λ > 0, D > 0: 완전 카오스 | 직조 실패 |

### 3.5 전통적 확률과의 관계

전통적 확률 P를 원한다면 두 축의 조합으로 유도 가능:

```
P ≈ Ω × Φ    (단순화)
```

단, P만으로는 역으로 Ω와 Φ를 분리할 수 없다.
AXOL의 2축 척도가 더 많은 정보를 담고 있다.

### 3.6 검증 벤치마크

알려진 동역학계에 대한 검증:

| 시스템 | λ_max | D | Ω (예측) | Φ (예측) |
|--------|-------|---|---------|---------|
| Lorenz 끌개 (σ=10, ρ=28, β=8/3) | ~0.91 | ~2.06 | ~0.52 | ~0.59 |
| 수렴 시스템 (λ=-2) | -2.0 | ~0 | 1.0 | ~1.0 |
| 균등 분포 | — | D_max | — | 0.5 |
| 델타 분포 | — | 0 | — | 1.0 |

---

## 4. 합성 규칙

### 4.1 직렬 합성

두 단계 A, B가 직렬로 연결될 때:

```
λ_total = λ_A + λ_B
Ω_total = 1 / (1 + max(λ_A + λ_B, 0))
D_total ≤ D_A + D_B
Φ_total ≥ Φ_A × Φ_B
```

**핵심:** 직렬 합성은 카오스를 누적한다.
두 개의 약한 카오스 단계(λ=0.3 + λ=0.3)가 합쳐지면
하나의 강한 카오스 파이프라인(λ=0.6)이 된다.

이것은 AXOL 고유의 통찰이 아니라 **동역학계 이론의 정리**다.
AXOL은 이 정리를 프로그래밍 파이프라인의 품질 예측에 적용한다.

### 4.2 병렬 합성

두 단계 A, B가 병렬로 결합될 때:

```
λ_total = max(λ_A, λ_B)
Ω_total = min(Ω_A, Ω_B)
D_total = max(D_A, D_B)
Φ_total = min(Φ_A, Φ_B)
```

**핵심:** 병렬 합성은 최약 링크에 의해 제한된다.

### 4.3 관측 후 재사용

관측 후 직물(tapestry)의 재사용 가능 여부는 Lyapunov 지수에 의해 결정된다:

- λ < 0 (수렴적): 관측이 상태를 소모하지 않음 → 재직조 불필요
- λ > 0 (카오스적): 관측이 상태를 교란 → 재직조 필요

이것은 기존 언어에서는 존재하지 않는 판단이다.
"이 함수를 호출한 뒤에 캐시를 무효화해야 하는가?"를 카오스 이론이 답한다.

---

## 5. 직조기 (Auto-tuning Weaver)

### 5.1 원리

프로그래머는 **원하는 품질(Ω, Φ)만 선언**하고,
시스템이 **필요한 구축 비용을 자동으로 산출/분배**한다.

```
프로그래머: "이 정도 품질이면 돼"  →  Ω, Φ 목표 지정
시스템:     "그러면 이만큼 구축해야 해"  →  구축 비용(E) 산출
```

### 5.2 구축 비용 (Construction Cost, E)

```
E = Σ_path [ iterations_to_converge(path) × path_complexity(path) ]
```

- **iterations_to_converge**: Lyapunov 지수에 의해 결정
  - λ ≪ 0: 빠른 수렴, ~O(1/|λ|) 반복
  - λ ≈ 0: 느린 수렴, ~O(1/ε) 반복
  - λ > 0: 수렴 없음, 비용 비한계 (경고 발생)
- **path_complexity**: 필요한 간섭 층 수
  - complexity = ceil(log₂(budget / BASE_COST))

```
                E (구축 비용)
                ↑
                │          ╱ Ω=0.99, Φ=0.99  (거의 정확 — 비쌈)
                │        ╱
                │      ╱
                │    ╱
                │  ╱  Ω=0.8, Φ=0.7  (대충 맞음 — 쌈)
                │╱
                └──────────────→ 로직 복잡도
```

### 5.3 직조기 동작 과정

```
[1] 로직 그래프 분석
    선언을 파싱 → 노드(연산)와 간선(의존관계) 추출

[2] 끌개 구축
    각 노드에 대해:
    - 관계 종류 → 궤적 행렬 생성
    - 간섭 층 적용 (예산에 비례)
    - Lyapunov 지수 추정 (Benettin QR)
    - 프랙탈 차원 추정 (박스 카운팅 / 상관 차원)

[3] 합성 규칙 적용
    - 직렬: λ 누적, D 합산
    - 병렬: λ 최대, D 최대
    → 전역 Ω, Φ 산출

[4] 행렬 사전합성 (최적화)
    선형 체인 → 단일 행렬로 합성
    비선형 체인 → Koopman 리프팅으로 합성

[5] 품질 보고
    예상 Ω, Φ를 프로그래머에게 반환
    목표 달성 불가 시 경고 및 대안 제안
```

### 5.4 예산 분배 전략

동일한 E 예산 안에서 모든 노드에 균등 분배하지 않는다.
핵심 경로에 집중 투자하고 주변 경로는 최소화한다.

```
예시: 3단계 파이프라인, 총 E = 200

  step1 (단순 변환):   E = 30   (15%)  ← 적게 구축해도 충분
  step2 (핵심 분석):   E = 120  (60%)  ← 집중 투자
  step3 (출력 포맷):   E = 50   (25%)  ← 중간
```

### 5.5 달성 불가능 감지

로직 구조상 목표 Ω, Φ에 도달할 수 없는 경우, 직조기가 이를 감지하고 보고한다.

달성 가능 조건:

```
Ω_target ≤ 1 / (1 + max(λ_max_path, 0))
Φ_target ≤ 1 / (1 + D_estimated / D_max)
```

달성 불가 시:

```
> weave predict_weather: WARNING
>   target:   Ω(0.99) Φ(0.99)
>   maximum:  Ω(0.71) Φ(0.68)  ← 로직 구조상 한계
>   reason:   chaotic dependency detected (λ_max = 0.41)
>   suggest:  lower target to Ω(0.7) Φ(0.7) or simplify logic
```

이는 기존 언어에서는 불가능한 피드백이다.
"이 로직은 본질적으로 카오스적이다"라는 정보를 **직조 시점에** 제공한다.

---

## 6. 비선형 확장: Koopman 연산자

### 6.1 선형 합성의 한계

행렬 사전합성(M_composed = M₁ × M₂ × ... × Mₙ)은 **선형 변환 체인**에만 적용된다.
비선형 단계(활성화 함수, 조건 분기 등)가 포함되면 행렬 곱으로 합성할 수 없다.

### 6.2 Koopman 연산자 이론

비선형 동역학계 `x_{k+1} = f(x_k)`에 대해,
상태 공간이 아닌 **관측량(observable) 공간**에서는 동역학이 선형이 된다.

Koopman 연산자 K는 관측량 g에 대해:

```
(Kg)(x) = g(f(x))
```

즉, 비선형 상태 변환 f를 관측량 공간에서의 **선형 연산자** K로 표현한다.

### 6.3 다항식 리프팅 (EDMD)

AXOL은 **확장 동적 모드 분해(EDMD)** 를 사용하여 유한 차원 Koopman 근사를 구한다.

```
원래 상태:  x ∈ R^n
리프팅:     ψ(x) = [x₁, x₂, ..., xₙ, x₁², x₁x₂, ..., xₙ²] ∈ R^m
            (m = lifted_dim(n, degree))

리프팅된 공간에서:  ψ(f(x)) ≈ K @ ψ(x)   (선형!)
```

degree=2에서 `lifted_dim(n) = n + n(n+1)/2`.

### 6.4 합성 경로

```
선형 체인:     M₁ @ M₂ @ ... @ Mₙ → 단일 행렬       → O(dim²) 관측
비선형 체인:   K₁ @ K₂ @ ... @ Kₙ → 단일 Koopman 행렬 → O(lifted_dim²) 관측
```

비선형의 경우 리프팅된 차원에서 O(lifted_dim²) 비용이 발생하나,
여전히 **깊이에 무관**한 관측이 가능하다.

### 6.5 한계

- Koopman 근사의 정확도는 degree와 n_samples에 의존
- 강한 비선형성(불연속, 극단적 발산)은 다항식 리프팅으로 포착되지 않음
- 차원 폭발: degree=2, dim=100 → lifted_dim ≈ 5,150
- MergeOp(다중 입력 결합)이 포함되면 Koopman 경로도 사용 불가 → fallback

---

## 7. 패러다임: Declare → Weave → Observe

### 7.1 세 단계의 재정의

| 기존 | AXOL | 실제 메커니즘 |
|------|------|------------|
| 코드 작성 (명령 나열) | **Declare** (관계 선언) | 위상 공간 구조 정의 |
| 컴파일 (기계어 번역) | **Weave** (직조) | 끌개 구축 + 행렬 합성 + Ω/Φ 보증 |
| 실행 (순차 처리) | **Observe** (관측) | 합성 행렬에 입력 통과 → 결과 |

### 7.2 용어 체계

| 기존 용어 | AXOL 용어 | 카오스 이론 대응 |
|----------|----------|---------------|
| compile | **weave** (직조) | 끌개(attractor) 구축 |
| compiler | **weaver** (직조기) | 끌개 구축 + 품질 추정 시스템 |
| binary | **tapestry** (직물) | 끌개 + 합성 행렬 + 품질 메트릭 |
| execute | **observe** (관측) | 끌개 위의 한 점으로 수렴 |
| runtime | **observatory** (관측소) | 관측 수행 환경 |

### 7.3 흐름 비교

```
[기존]
  Write    →  Compile  →  Execute
  코드 작성     번역       순차 실행
  명령 나열   → 기계어   → 매 호출 O(depth × dim²)

[AXOL]
  Declare  →  Weave            →  Observe
  관계 선언     끌개 구축 + 합성     합성 결과에 입력 통과
  구조 기술   → O(depth × dim³)  → 매 호출 O(dim²)
               1회                  depth 무관
```

---

## 8. 코드 예시 (개념적)

### 8.1 기본: 관계 선언과 관측

```
// 직조: 관계를 선언하고 품질 목표 지정
entangle search(query, database) @ Ω(0.9) Φ(0.7) {
    relevance ⟨∝⟩ similarity(query, database)
    ranking   ⟨∝⟩ relevance × recency
}

// 관측: 인자 대입 → 결과
result = observe search("AXOL", db)
// → { value: [...결과들...], Ω: 0.91, Φ: 0.73 }
```

### 8.2 수치 연산: 선명도 중시

```
entangle calculate(a, b) @ Ω(0.8) Φ(0.99) {
    result ⟨∝⟩ a ⟨+⟩ b
}

result = observe calculate(2, 3)
// → { value: 5.0, Ω: 0.82, Φ: 0.997 }
```

### 8.3 분류: 결속도 중시

```
entangle classify(image) @ Ω(0.9) Φ(0.6) {
    category ⟨∝⟩ features(image)
}

result = observe classify(photo)
// → { value: "고양이", Ω: 0.93, Φ: 0.58 }
```

### 8.4 품질 부족 시 재관측

```
result = observe search("AXOL", db)

if result.Ω < 0.95 {
    result = reobserve search("AXOL", db) × 10
    // 10회 관측 → 분포 수렴 → Ω 상승
}
```

재관측에 의한 품질 향상:

```
Ω_k ≥ 1 - (1 - Ω_1)^k    (모드 안정성의 수렴)
```

### 8.5 직조 결과 리포트

```
> weave search: complete
>   target:   Ω(0.9)  Φ(0.7)
>   actual:   Ω(0.91) Φ(0.73)
>   λ_max:    -0.10   (수렴적)
>   D:        1.23    (프랙탈 차원)
>   cost:     E = 342
>   nodes:    2 (relevance, ranking)
>   reusable: yes     (λ < 0 → 재직조 불필요)
```

---

## 9. 실증 검증: 극한 성능 벤치마크

### 9.1 실험 설계

AXOL의 핵심 주장 — "직조는 한 번, 관측은 깊이에 무관" — 을 극한 조건에서 검증하였다.

| 실험 | 변수 | 범위 | 검증 대상 |
|------|------|------|----------|
| 1. 차원 스케일링 | dim | 4 → 4,096 | dim 증가 시 관측 비용 변화 |
| 2. 깊이 스케일링 | depth | 5 → 5,000 | 관측의 깊이 독립성 |
| 3. 반복 관측 상각 | count | 1 → 1,000,000 | 직조 비용의 상각 |
| 4. 차원×깊이 복합 | dim×depth | (64,10)→(1024,100) | 복합 스케일링 |

### 9.2 핵심 결과

#### 실험 1: 관측 시간 vs 차원 (depth=1)

| Dimension | Traditional | AXOL Observe | 비율 |
|-----------|-------------|--------------|------|
| 4 | 17.9 μs | 24.3 μs | 0.7x |
| 64 | 13.4 μs | 18.1 μs | 0.7x |
| 256 | 53.8 μs | 25.0 μs | **2.2x** |
| 1,024 | 2,650 μs | 259 μs | **10.2x** |
| 4,096 | 39,503 μs | 2,616 μs | **15.1x** |

dim이 1024배(4→4096) 증가할 때 관측 시간은 107배 증가. **차원 독립성은 성립하지 않으며, O(dim²) 스케일링**을 보인다. 그러나 dim=4096에서도 **2.6ms** 수준이며, Traditional 대비 **15x 가속**은 유효하다.

#### 실험 2: 파이프라인 깊이 스케일링 (dim=16)

| Depth | Traditional | Composed Observe | 비율 |
|-------|-------------|------------------|------|
| 5 | 21.6 μs | 10.0 μs | 2x |
| 50 | 146.5 μs | 9.9 μs | 15x |
| 500 | 1,434 μs | 9.8 μs | 146x |
| 5,000 | 20,263 μs | **8.4 μs** | **2,412x** |

**핵심 발견:** Composed Observe는 depth=5000에서도 ~10μs로 **완벽한 수평선**을 그린다.
행렬 사전합성에 의해 depth가 O(1)로 상각됨을 실증적으로 확인.

#### 실험 3: 반복 관측 상각 (dim=16, depth=100)

| 관측 횟수 | Traditional/회 | AXOL 상각/회 | 직조 상각 |
|-----------|---------------|-------------|----------|
| 1 | 355.6 μs | 738.8 ms | 738.2 ms |
| 1,000 | 355.6 μs | 1,304 μs | 738.2 μs |
| 100,000 | 355.6 μs | 573.8 μs | 7.4 μs |
| 1,000,000 | 355.6 μs | 567.1 μs | **0.7 μs** |

**핵심 발견:** 100만 회 관측 시 직조 상각 비용 = 0.7μs → **사실상 제로**.

#### 실험 4: 차원 × 깊이 복합 스케일링

| (dim, depth) | 복잡도 | Traditional | Composed | Speedup |
|--------------|--------|-------------|----------|---------|
| (64, 10) | 40,960 | 62.7 μs | 12.8 μs | **5x** |
| (256, 100) | 6.5M | 6.18 ms | 73.9 μs | **84x** |
| (512, 500) | 131M | 380.9 ms | 679.6 μs | **560x** |
| (1024, 100) | 105M | 277.3 ms | 2.68 ms | **104x** |

복잡도가 3,200배 증가할 때(40K→131M), Traditional은 6,075배 느려지지만 Composed는 53배만 증가.

### 9.3 복잡도 요약

```
기존 순차 실행:  cost_per_call = O(depth × dim²)     ← 매 호출마다 N단계 순차 실행
AXOL 직조:      cost_one_time = O(depth × dim³)     ← 1회 직조 (행렬 합성 + 품질 보증)
AXOL 관측:      cost_per_call = O(dim²)              ← depth 무관! 단일 행렬-벡터 곱
```

N회 관측 시 총 비용:

```
Traditional = N × O(depth × dim²)
AXOL        = O(depth × dim³) + N × O(dim²)

∴ N >> depth × dim 일 때, AXOL은 depth에 비례하여 가속.
  depth=5000에서 2,412x, (512,500)에서 560x 확인.
```

### 9.4 실험의 한계와 시사점

1. **O(1) depth의 조건**: 행렬 사전합성은 **선형 변환 체인(TransformOp)**에만 적용된다. MergeOp, 비선형 연산, 분기가 포함된 파이프라인은 순차 실행으로 fallback한다. Koopman 경로가 비선형을 부분적으로 커버하나 근사이며, 차원 폭발이 수반된다.
2. **O(dim²)이지 O(1)이 아니다**: 관측 비용은 깊이에 무관하나 차원에는 이차적으로 의존한다. "관측 비용이 일정하다"가 아니라 "관측 비용이 깊이에 무관하다"가 정확한 진술이다.
3. **dim=512 전환점**: dim ≤ 256에서는 AXOL 오버헤드가 우세하나, dim ≥ 512부터 AXOL이 역전. 이는 cache-friendly한 단일 행렬 연산 구조의 이점.
4. **직조 비용의 현실**: dim=4096에서 직조에 ~1분 이상 소요. 대규모 시스템에서의 직조 최적화가 추후 과제.
5. **정확도**: Composed observe의 결과는 Traditional 순차실행과 float32 정밀도 범위 내에서 일치한다 (Hellinger distance < 0.01).

---

## 10. 적용 범위와 한계

### 10.1 AXOL이 유효한 경우

- **반복 쿼리가 많은 파이프라인**: 직조 1회, 관측 N회 → N이 클수록 이득
- **깊은 선형 변환 체인**: depth가 클수록 가속 비율 증가
- **품질 보증이 필요한 경우**: "이 연산 결과를 얼마나 신뢰할 수 있는가?"에 정량적 답 필요 시
- **카오스 감지가 가치 있는 경우**: 로직의 본질적 불확실성을 직조 시점에 알 수 있음

### 10.2 AXOL이 유효하지 않은 경우

- **1회성 실행**: 직조 비용이 상각되지 않으면 오히려 느림
- **저차원 단순 연산**: dim ≤ 256이면 오버헤드가 이득을 상쇄
- **강한 비선형/분기 의존**: 선형 합성도 Koopman 합성도 불가능한 구조
- **정확한 결정적 결과가 필수인 경우**: AXOL은 확률적 품질 모델이므로 100% 정확도를 보장하지 않음

### 10.3 정직한 자기 평가

AXOL의 핵심 메커니즘(행렬 사전합성)은 선형대수의 기본 성질이다.
이것 자체는 새로운 발견이 아니다.

AXOL의 실제 기여는:

1. **카오스 이론을 프로그래밍 품질 척도로 도입**: Lyapunov 지수 → Ω, 프랙탈 차원 → Φ
2. **합성의 품질 전파를 수학적으로 보장**: 직렬/병렬 합성 규칙
3. **달성 불가능성을 사전에 감지**: "이 로직은 본질적으로 카오스적이다"
4. **비선형 확장을 Koopman 이론으로 연결**: 순수 선형 한계를 넘어서는 경로 제시
5. **오프라인/온라인 분리에 품질 보증을 내장**: 단순 캐싱이 아닌 보증된 캐싱

---

## 11. 미해결 과제

| 과제 | 현재 상태 | 설명 |
|------|----------|------|
| Ω, Φ의 범위 | 0~1로 정의됨 | 다른 스케일이 더 자연스러운지 검토 필요 |
| E의 산출 공식 | 구현됨 (cost.py) | 이론적 최적성 미증명 |
| 관측 후 끌개 상태 보존 | λ 기반 규칙 구현 | 비선형 경우의 엄밀한 증명 필요 |
| 직물의 내부 자료구조 최적화 | numpy 행렬 기반 | 희소 행렬, GPU 최적화 여지 |
| 관계 선언 문법의 형식적 의미론 | DSL 파서 구현됨 | 형식 문법으로의 엄밀한 정의 필요 |
| 게으른 직조 (lazy weaving) | 미구현 | 관측 경로에 필요한 것만 구축하는 최적화 |
| 끌개 범위 제한 | 미구현 | 전역 vs 로컬 끌개 클러스터 관리 |
| 관측의 부작용 모델 | 미정의 | 관측이 외부 세계에 영향을 줄 때의 처리 |
| Koopman 근사 오차 한계 | 미증명 | degree/n_samples와 오차의 이론적 관계 |

---

## 12. 요약

AXOL은 다음을 주장한다:

1. **파이프라인의 연산 비용을 직조(오프라인)와 관측(온라인)으로 분리할 수 있다.** 관측 비용은 파이프라인 깊이에 무관하며 O(dim²)이다.
2. **카오스 이론의 Lyapunov 지수와 프랙탈 차원을 사용하여 연산 결과의 품질을 정량적으로 보증한다.** 결속도(Ω)는 결과의 안정성, 선명도(Φ)는 결과의 정밀도를 측정한다.
3. **합성의 품질 전파가 동역학계 이론에 의해 수학적으로 보장된다.** 직렬 합성은 카오스를 누적하고, 병렬 합성은 최약 링크에 의해 제한된다.
4. **직조기가 목표 품질의 달성 가능성을 사전에 판정한다.** "이 로직은 본질적으로 카오스적이다"라는 피드백을 직조 시점에 제공한다.
5. **Koopman 연산자 이론을 통해 비선형 파이프라인으로의 확장 경로가 존재한다.** 다항식 리프팅에 의한 근사이며, 정확도와 차원의 트레이드오프가 수반된다.
6. **이는 번역(compile)→실행(execute)이 아닌, 직조(weave)→관측(observe)이라는 연산 모델이다.** 직조는 끌개를 구축하고, 관측은 끌개 위의 한 점으로 수렴시킨다.
