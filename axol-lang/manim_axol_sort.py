"""
aXOL Resonance Sort vs std::sort — Real Benchmark Visualization
Manim Community Edition

Data source: bench_sort_results.json (generated by `cargo run --release --bin bench_sort`)

Usage:
    manim -pql manim_axol_sort.py HookScene
    manim -pql manim_axol_sort.py SortingRace
    manim -pql manim_axol_sort.py AccuracyReveal
    manim -pql manim_axol_sort.py ComplexityGraph
    manim -pql manim_axol_sort.py SpeedupTable
    manim -pql manim_axol_sort.py PhysicalMetaphor
    manim -pql manim_axol_sort.py SimilarityReveal # n=1M 유사도 비교
    manim -pqh manim_axol_sort.py FullVideo       # 전체 (고화질)
"""

from manim import *
import json
import random
import numpy as np
from pathlib import Path


# ── JSON 로더 ──

_DATA = None

def load_data():
    global _DATA
    if _DATA is not None:
        return _DATA
    p = Path(__file__).parent / "bench_sort_results.json"
    with open(p, "r") as f:
        _DATA = json.load(f)
    return _DATA


# ── 한글 폰트 ──
F = "Malgun Gothic"

# ── 색상 팔레트 ──
BG_COLOR = "#1a1a2e"
TRAD_COLOR = "#e94560"
AXOL_COLOR = "#0f3460"
AXOL_GLOW = "#00d2ff"
TEXT_COLOR = "#eaeaea"
ACCENT = "#f5c518"


class HookScene(Scene):
    """장면 1: 훅 - 실측 기반 극적 비교"""

    def construct(self):
        self.camera.background_color = BG_COLOR
        data = load_data()
        bench = {b["n"]: b for b in data["benchmarks"]}

        title = Text("만약 정렬이 O(n)이라면?", font_size=48, color=TEXT_COLOR, font=F)
        title.to_edge(UP, buff=0.5)
        self.play(Write(title), run_time=1.5)

        # n=1M 실측 데이터
        b = bench[1000000]
        std_us = b["std_sort_us"]
        res_us = b["hybrid_sort_us"]
        speedup = b["hybrid_speedup"]

        n_text = Text("n = 1,000,000 (실측)", font_size=36, color=ACCENT, font=F)
        n_text.next_to(title, DOWN, buff=0.5)
        self.play(FadeIn(n_text, shift=UP), run_time=0.8)

        line = Line(UP * 2, DOWN * 2, color=GREY_D, stroke_width=1)
        self.play(Create(line), run_time=0.3)

        trad_label = Text("std::sort", font_size=28, color=TRAD_COLOR, font=F)
        trad_label.move_to(LEFT * 3.5 + UP * 1.5)
        axol_label = Text("aXOL Resonance", font_size=28, color=AXOL_GLOW, font=F)
        axol_label.move_to(RIGHT * 3.5 + UP * 1.5)
        self.play(FadeIn(trad_label), FadeIn(axol_label), run_time=0.5)

        trad_bar_bg = Rectangle(
            width=5, height=0.4, color=GREY_D,
            fill_opacity=0.3, stroke_width=1
        ).move_to(LEFT * 3.5 + DOWN * 0)
        axol_bar_bg = Rectangle(
            width=5, height=0.4, color=GREY_D,
            fill_opacity=0.3, stroke_width=1
        ).move_to(RIGHT * 3.5 + DOWN * 0)

        self.play(FadeIn(trad_bar_bg), FadeIn(axol_bar_bg), run_time=0.3)

        trad_timer = Text("0.000ms", font_size=24, color=TRAD_COLOR, font=F)
        trad_timer.next_to(trad_bar_bg, DOWN, buff=0.3)
        axol_timer = Text("0.000ms", font_size=24, color=AXOL_GLOW, font=F)
        axol_timer.next_to(axol_bar_bg, DOWN, buff=0.3)
        self.add(trad_timer, axol_timer)

        # aXOL finishes first
        axol_bar_full = Rectangle(
            width=5, height=0.4, color=AXOL_GLOW,
            fill_opacity=0.8, stroke_width=0
        ).align_to(axol_bar_bg, LEFT).align_to(axol_bar_bg, DOWN)

        axol_done = Text(f"{res_us / 1000:.1f}ms", font_size=24, color=AXOL_GLOW, font=F)
        axol_done.next_to(axol_bar_bg, DOWN, buff=0.3)
        axol_check = Text("DONE", font_size=32, color=AXOL_GLOW, font=F)
        axol_check.next_to(axol_bar_bg, RIGHT, buff=0.3)

        self.play(
            GrowFromEdge(axol_bar_full, LEFT),
            Transform(axol_timer, axol_done),
            FadeIn(axol_check, scale=1.5),
            run_time=0.3
        )
        self.play(Flash(axol_bar_full, color=AXOL_GLOW, flash_radius=0.5), run_time=0.3)

        # std::sort slowly fills
        trad_bar = Rectangle(
            width=0, height=0.4, color=TRAD_COLOR,
            fill_opacity=0.8, stroke_width=0
        ).align_to(trad_bar_bg, LEFT).align_to(trad_bar_bg, DOWN)

        steps = 5
        for i in range(steps):
            frac = (i + 1) / steps
            new_bar = Rectangle(
                width=5 * frac, height=0.4, color=TRAD_COLOR,
                fill_opacity=0.8, stroke_width=0
            ).align_to(trad_bar_bg, LEFT).align_to(trad_bar_bg, DOWN)
            ms = std_us / 1000 * frac
            new_timer = Text(f"{ms:.1f}ms", font_size=24, color=TRAD_COLOR, font=F)
            new_timer.next_to(trad_bar_bg, DOWN, buff=0.3)
            self.play(
                Transform(trad_bar, new_bar),
                Transform(trad_timer, new_timer),
                run_time=0.8
            )

        trad_done = Text("DONE", font_size=32, color=TRAD_COLOR, font=F)
        trad_done.next_to(trad_bar_bg, RIGHT, buff=0.3)
        self.play(FadeIn(trad_done), run_time=0.3)

        if speedup >= 1:
            comp_text = f"{speedup:.1f}x faster (runtime)"
        else:
            comp_text = f"~{1/speedup:.1f}x (cache-bound at 1M)"
        comparison = Text(comp_text, font_size=40, color=ACCENT, font=F)
        comparison.move_to(DOWN * 2.5)
        self.play(Write(comparison), run_time=1.0)
        self.wait(2)


class SortingRace(Scene):
    """장면 2: n=10000 실제 결과 막대 + 오차 하이라이트"""

    def construct(self):
        self.camera.background_color = BG_COLOR
        data = load_data()
        vis = data["visualization"]
        gt = vis["ground_truth"]
        res = vis["hybrid_result"]
        errors = vis["hybrid_error_indices"]
        n_total = vis["n"]
        accuracy = 1.0 - len(errors) / n_total

        # Downsample for visualization (show 60 bars)
        N = 60
        step = max(1, n_total // N)
        gt_sampled = [gt[i * step] for i in range(N)]
        res_sampled = [res[i * step] for i in range(N)]
        error_set = set(errors)
        error_bars = [i for i in range(N) if i * step in error_set]

        max_val = max(max(gt_sampled), max(res_sampled))
        BAR_W = 5.5
        BAR_BOTTOM = -2.5
        BAR_MAX_H = 3.8
        bar_width = BAR_W / N * 0.85
        gap = BAR_W / N

        title = Text("Sorting Race (n=10,000 실측)", font_size=36, color=TEXT_COLOR, font=F)
        title.to_edge(UP, buff=0.3)
        self.play(Write(title), run_time=0.8)

        trad_label = Text("std::sort  O(n log n)", font_size=22, color=TRAD_COLOR, font=F)
        trad_label.move_to(LEFT * 3.5 + UP * 2.2)
        axol_label = Text("aXOL Resonance  O(1)", font_size=22, color=AXOL_GLOW, font=F)
        axol_label.move_to(RIGHT * 3.5 + UP * 2.2)
        divider = Line(UP * 2.5, DOWN * 3, color=GREY_D, stroke_width=1)
        self.play(FadeIn(trad_label), FadeIn(axol_label), Create(divider), run_time=0.5)

        def bar_pos(idx, x_offset):
            return RIGHT * (x_offset - BAR_W / 2 + idx * gap + gap / 2)

        def make_bar(val, idx, x_offset, color):
            h = (val / max_val) * BAR_MAX_H
            h = max(h, 0.02)
            bar = Rectangle(
                width=bar_width, height=h,
                color=color, fill_opacity=0.7, stroke_width=0
            )
            bar.move_to(bar_pos(idx, x_offset) + UP * (BAR_BOTTOM + h / 2))
            return bar

        # Left: shuffled state
        random.seed(42)
        shuffled_idx = list(range(N))
        random.shuffle(shuffled_idx)
        shuffled_vals = [gt_sampled[shuffled_idx[i]] for i in range(N)]

        trad_bars = VGroup(*[make_bar(v, i, -3.5, TRAD_COLOR) for i, v in enumerate(shuffled_vals)])
        axol_bars = VGroup(*[make_bar(v, i, 3.5, AXOL_GLOW) for i, v in enumerate(shuffled_vals)])

        self.play(FadeIn(trad_bars), FadeIn(axol_bars), run_time=0.5)
        self.wait(0.3)

        # aXOL: instant sort using resonance result
        axol_sorted = VGroup(*[make_bar(v, i, 3.5, AXOL_GLOW) for i, v in enumerate(res_sampled)])
        # Highlight errors in red
        for idx in error_bars:
            axol_sorted[idx].set_color(TRAD_COLOR)

        self.play(
            Transform(axol_bars, axol_sorted),
            Flash(axol_sorted.get_center(), color=AXOL_GLOW, flash_radius=1.5, num_lines=12),
            run_time=0.15
        )

        bench_10k = next(b for b in data["benchmarks"] if b["n"] == 10000)
        axol_time = bench_10k["hybrid_sort_us"]
        axol_done_text = Text(f"DONE ({axol_time:.0f}μs)", font_size=22, color=AXOL_GLOW, font=F)
        axol_done_text.move_to(RIGHT * 3.5 + DOWN * 3.2)
        self.play(FadeIn(axol_done_text, scale=1.5), run_time=0.2)

        # QuickSort: selection sort animation (subset)
        arr = shuffled_vals.copy()
        swap_speed = 0.06
        max_swaps = 25
        swaps_done = 0
        for i in range(len(arr)):
            if swaps_done >= max_swaps:
                break
            min_idx = i
            for j in range(i + 1, len(arr)):
                if arr[j] < arr[min_idx]:
                    min_idx = j
            if min_idx != i:
                trad_bars[i].set_color(ACCENT)
                trad_bars[min_idx].set_color(ACCENT)
                self.wait(swap_speed * 0.3)

                pos_i = bar_pos(i, -3.5)
                pos_min = bar_pos(min_idx, -3.5)
                h_i = (arr[i] / max_val) * BAR_MAX_H
                h_min = (arr[min_idx] / max_val) * BAR_MAX_H

                self.play(
                    trad_bars[i].animate.move_to(pos_min + UP * (BAR_BOTTOM + h_i / 2)),
                    trad_bars[min_idx].animate.move_to(pos_i + UP * (BAR_BOTTOM + h_min / 2)),
                    run_time=swap_speed,
                )

                arr[i], arr[min_idx] = arr[min_idx], arr[i]
                trad_bars[i], trad_bars[min_idx] = trad_bars[min_idx], trad_bars[i]
                trad_bars[i].set_color(GREEN_C)
                swaps_done += 1
            else:
                trad_bars[i].set_color(GREEN_C)
                self.wait(swap_speed * 0.3)

        # Skip to sorted
        sorted_trad = VGroup(*[make_bar(v, i, -3.5, GREEN_C) for i, v in enumerate(gt_sampled)])
        self.play(Transform(trad_bars, sorted_trad), run_time=0.5)

        std_time = bench_10k["std_sort_us"]
        trad_done_text = Text(f"DONE ({std_time:.0f}μs)", font_size=22, color=TRAD_COLOR, font=F)
        trad_done_text.move_to(LEFT * 3.5 + DOWN * 3.2)
        self.play(FadeIn(trad_done_text), run_time=0.3)

        speedup_text = Text(
            f"Speedup: {bench_10k['hybrid_speedup']:.1f}x  |  Accuracy: {accuracy * 100:.1f}%",
            font_size=28, color=ACCENT, font=F
        )
        speedup_text.to_edge(DOWN, buff=0.2)
        self.play(Write(speedup_text), run_time=1.0)
        self.wait(2)


class AccuracyReveal(Scene):
    """장면 3: 실측 정확도 — 차이를 찾아보세요 → 없습니다"""

    def construct(self):
        self.camera.background_color = BG_COLOR
        data = load_data()
        vis = data["visualization"]
        errors = vis["hybrid_error_indices"]
        n_total = vis["n"]
        accuracy = 1.0 - len(errors) / n_total
        n_errors = len(errors)

        title = Text("그런데, 정확할까?", font_size=44, color=TEXT_COLOR, font=F)
        title.to_edge(UP, buff=0.5)
        self.play(Write(title), run_time=1.0)
        self.wait(0.5)

        # Show downsampled bars (100 bars)
        gt = vis["ground_truth"]
        res = vis["hybrid_result"]
        n_bars = 100
        step = max(1, n_total // n_bars)
        gt_s = [gt[i * step] for i in range(n_bars)]
        res_s = [res[i * step] for i in range(n_bars)]
        max_val = max(max(gt_s), max(res_s))

        bar_width = 0.1
        gap = 0.12
        max_h = 2.5
        x_start = -6

        def make_bar_group(values, y_offset, color, label_text):
            bars = VGroup()
            for i, v in enumerate(values):
                h = (v / max_val) * max_h
                bar = Rectangle(
                    width=bar_width, height=max(h, 0.01),
                    color=color, fill_opacity=0.7, stroke_width=0
                )
                bar.move_to(RIGHT * (x_start + i * gap) + UP * (y_offset + h / 2))
                bars.add(bar)
            label = Text(label_text, font_size=22, color=color, font=F)
            label.move_to(RIGHT * (x_start - 1.5) + UP * (y_offset + max_h / 2))
            return VGroup(bars, label)

        perfect_group = make_bar_group(gt_s, 0.5, GREEN_C, "std::sort\n결과")
        approx_group = make_bar_group(res_s, -2.5, AXOL_GLOW, "aXOL\n결과")

        self.play(FadeIn(perfect_group), run_time=1.0)
        self.wait(0.5)
        self.play(FadeIn(approx_group), run_time=1.0)
        self.wait(1.0)

        # "차이를 찾아보세요"
        find_text = Text("차이를 찾을 수 있나요?", font_size=32, color=ACCENT, font=F)
        find_text.to_edge(DOWN, buff=0.5)
        self.play(Write(find_text), run_time=1.0)
        self.wait(2.0)
        self.play(FadeOut(find_text), run_time=0.3)

        if n_errors == 0:
            # 100% 정확 — 오차 없음 연출
            answer = Text("없습니다.", font_size=44, color=AXOL_GLOW, font=F)
            answer.to_edge(DOWN, buff=1.5)
            self.play(Write(answer), run_time=0.8)
            self.wait(0.5)

            # 겹쳐서 완전 일치 증명
            self.play(
                approx_group.animate.move_to(perfect_group.get_center()),
                run_time=1.5
            )
            self.wait(0.5)

            overlap_text = Text(
                f"n={n_total:,}개 원소, 오차 0개 — 100% 일치",
                font_size=28, color=GREEN_C, font=F
            )
            overlap_text.to_edge(DOWN, buff=0.5)
            self.play(FadeOut(answer), Write(overlap_text), run_time=1.0)
            self.wait(1.0)

            conclusion = VGroup(
                Text("O(1)/원소 정렬 판단", font_size=28, color=AXOL_GLOW, font=F),
                Text("+", font_size=28, color=TEXT_COLOR, font=F),
                Text("100% 정확도", font_size=28, color=GREEN_C, font=F),
            ).arrange(RIGHT, buff=0.3).next_to(overlap_text, DOWN, buff=0.4)
            self.play(Write(conclusion), run_time=1.0)
            self.wait(2)

        else:
            # 오차가 있는 경우 — 오차 위치 하이라이트
            error_set = set(errors)
            error_bar_indices = [i for i in range(n_bars) if i * step in error_set]
            for idx in error_bar_indices:
                approx_group[0][idx].set_color(TRAD_COLOR)
            self.play(
                *[Flash(approx_group[0][idx], color=TRAD_COLOR, flash_radius=0.2)
                  for idx in error_bar_indices[:5]],
                run_time=0.5
            )

            acc_pct = accuracy * 100
            stats = VGroup(
                Text(f"std::sort  →  100% 정확  →  O(n log n)", font_size=24, color=GREEN_C, font=F),
                Text(f"aXOL       →  {acc_pct:.2f}% 정확 ({n_errors}개 오차)  →  O(1)/원소", font_size=24, color=AXOL_GLOW, font=F),
            ).arrange(DOWN, buff=0.3).to_edge(DOWN, buff=0.5)
            self.play(Write(stats[0]), run_time=0.8)
            self.play(Write(stats[1]), run_time=0.8)
            self.wait(2)


class ComplexityGraph(Scene):
    """장면 4: O(n log n) vs O(n) 실측 데이터 포인트 오버레이"""

    def construct(self):
        self.camera.background_color = BG_COLOR
        data = load_data()
        benchmarks = data["benchmarks"]

        title = Text("시간복잡도 비교 (실측)", font_size=40, color=TEXT_COLOR, font=F)
        title.to_edge(UP, buff=0.3)
        self.play(Write(title), run_time=0.8)

        # Log-log scale: x = log10(n), y = log10(us)
        x_min, x_max = 1.5, 6.5   # log10(100) ~ log10(1M)
        y_min, y_max = -1, 5       # log10(0.1us) ~ log10(100000us)

        axes = Axes(
            x_range=[x_min, x_max, 1], y_range=[y_min, y_max, 1],
            x_length=9, y_length=5,
            axis_config={"color": GREY_B, "include_numbers": False, "stroke_width": 2},
            tips=True,
        ).move_to(DOWN * 0.3)

        x_label = Text("n", font_size=28, color=GREY_B, font=F)
        x_label.next_to(axes.x_axis, RIGHT, buff=0.2)
        y_label = Text("시간 (μs)", font_size=28, color=GREY_B, font=F)
        y_label.next_to(axes.y_axis, UP, buff=0.2)
        self.play(Create(axes), Write(x_label), Write(y_label), run_time=1.0)

        # Axis labels
        n_labels = VGroup()
        for log_n, label in [(2, "100"), (3, "1K"), (4, "10K"), (5, "100K"), (6, "1M")]:
            t = Text(label, font_size=16, color=GREY_C, font=F)
            t.next_to(axes.c2p(log_n, y_min), DOWN, buff=0.15)
            n_labels.add(t)
        self.play(FadeIn(n_labels), run_time=0.5)

        # Theoretical curves
        nlogn_curve = axes.plot(
            lambda x: x + np.log10(x * np.log(10)) - 1.5,
            x_range=[x_min + 0.1, x_max - 0.1], color=TRAD_COLOR, stroke_width=2, stroke_opacity=0.5,
        )
        nlogn_label = Text("O(n log n)", font_size=20, color=TRAD_COLOR, font=F)
        nlogn_label.next_to(axes.c2p(6.2, 4.5), RIGHT, buff=0.1)

        on_curve = axes.plot(
            lambda x: x - 1.5,
            x_range=[x_min + 0.1, x_max - 0.1], color=AXOL_GLOW, stroke_width=2, stroke_opacity=0.5,
        )
        on_label = Text("O(1)/elem — aXOL", font_size=20, color=AXOL_GLOW, font=F)
        on_label.next_to(axes.c2p(6.2, 3.5), RIGHT, buff=0.1)

        self.play(Create(nlogn_curve), Write(nlogn_label), run_time=1.5)
        self.play(Create(on_curve), Write(on_label), run_time=1.5)

        # Plot real data points
        std_dots = VGroup()
        res_dots = VGroup()
        for b in benchmarks:
            log_n = np.log10(b["n"])
            log_std = np.log10(max(b["std_sort_us"], 0.01))
            log_res = np.log10(max(b["hybrid_sort_us"], 0.01))

            d1 = Dot(axes.c2p(log_n, log_std), radius=0.08, color=TRAD_COLOR)
            d2 = Dot(axes.c2p(log_n, log_res), radius=0.08, color=AXOL_GLOW)
            std_dots.add(d1)
            res_dots.add(d2)

        self.play(FadeIn(std_dots, scale=2), run_time=0.8)
        self.play(FadeIn(res_dots, scale=2), run_time=0.8)

        # Labels for dots
        legend = VGroup(
            VGroup(Dot(radius=0.06, color=TRAD_COLOR), Text("std::sort 실측", font_size=16, color=TRAD_COLOR, font=F)).arrange(RIGHT, buff=0.15),
            VGroup(Dot(radius=0.06, color=AXOL_GLOW), Text("aXOL 실측", font_size=16, color=AXOL_GLOW, font=F)).arrange(RIGHT, buff=0.15),
        ).arrange(DOWN, buff=0.15, aligned_edge=LEFT).to_corner(DR, buff=0.5)
        self.play(FadeIn(legend), run_time=0.5)

        # Speedup annotation at n=10K
        b10k = next(b for b in benchmarks if b["n"] == 10000)
        log_n = np.log10(10000)
        log_std = np.log10(b10k["std_sort_us"])
        log_res = np.log10(b10k["hybrid_sort_us"])
        brace = BraceBetweenPoints(
            axes.c2p(log_n + 0.15, log_std),
            axes.c2p(log_n + 0.15, log_res),
            direction=RIGHT, color=ACCENT
        )
        gap_text = Text(f"{b10k['hybrid_speedup']:.1f}x", font_size=18, color=ACCENT, font=F)
        gap_text.next_to(brace, RIGHT, buff=0.1)
        self.play(Create(brace), Write(gap_text), run_time=1.0)
        self.wait(2)


class SpeedupTable(Scene):
    """장면 5 (신규): n별 실측 성능 테이블"""

    def construct(self):
        self.camera.background_color = BG_COLOR
        data = load_data()
        benchmarks = data["benchmarks"]

        title = Text("실측 벤치마크 결과", font_size=40, color=TEXT_COLOR, font=F)
        title.to_edge(UP, buff=0.4)
        self.play(Write(title), run_time=0.8)

        # Table header
        headers = ["n", "std::sort", "pure O(1)", "hybrid", "accuracy", "speedup"]
        col_x = [-5.0, -3.2, -1.4, 0.4, 2.2, 4.0]
        header_row = VGroup()
        for i, h in enumerate(headers):
            t = Text(h, font_size=20, color=ACCENT, font=F, weight=BOLD)
            t.move_to(RIGHT * col_x[i] + UP * 2.0)
            header_row.add(t)

        # Units row
        units = ["", "(μs)", "(μs)", "(μs)", "(%)", "(x)"]
        unit_row = VGroup()
        for i, u in enumerate(units):
            t = Text(u, font_size=14, color=GREY_C, font=F)
            t.move_to(RIGHT * col_x[i] + UP * 1.6)
            unit_row.add(t)

        self.play(FadeIn(header_row), FadeIn(unit_row), run_time=0.5)

        hline = Line(LEFT * 6 + UP * 1.4, RIGHT * 5.5 + UP * 1.4, color=GREY_D, stroke_width=1)
        self.play(Create(hline), run_time=0.2)

        # Data rows
        for row_i, b in enumerate(benchmarks):
            y = 0.8 - row_i * 0.8
            vals = [
                f"{b['n']:,}",
                f"{b['std_sort_us']:.1f}",
                f"{b['pure_sort_us']:.1f}",
                f"{b['hybrid_sort_us']:.1f}",
                f"{b['hybrid_accuracy'] * 100:.1f}",
                f"{b['hybrid_speedup']:.2f}",
            ]
            colors = [TEXT_COLOR, TRAD_COLOR, GREY_B, AXOL_GLOW, GREEN_C,
                      AXOL_GLOW if b['hybrid_speedup'] >= 1.0 else TRAD_COLOR]

            row_group = VGroup()
            for i, (v, c) in enumerate(zip(vals, colors)):
                t = Text(v, font_size=18, color=c, font=F)
                t.move_to(RIGHT * col_x[i] + UP * y)
                row_group.add(t)

            self.play(FadeIn(row_group), run_time=0.4)

        # Summary
        best = max(benchmarks, key=lambda b: b["hybrid_speedup"])
        summary = Text(
            f"Peak speedup: {best['hybrid_speedup']:.1f}x at n={best['n']:,}",
            font_size=28, color=ACCENT, font=F
        )
        summary.move_to(DOWN * 3.0)
        self.play(Write(summary), run_time=1.0)
        self.wait(2)


class PhysicalMetaphor(Scene):
    """장면 6: 소리굽쇠 공명 비유"""

    def construct(self):
        self.camera.background_color = BG_COLOR

        title = Text("왜 O(n)이 가능한가?", font_size=40, color=TEXT_COLOR, font=F)
        title.to_edge(UP, buff=0.5)
        self.play(Write(title), run_time=1.0)

        trad_title = Text("전통: 비교 정렬", font_size=24, color=TRAD_COLOR, font=F)
        trad_title.move_to(LEFT * 3.5 + UP * 2)
        self.play(Write(trad_title), run_time=0.5)

        forks_left = VGroup()
        for i in range(12):
            row, col = i // 4, i % 4
            fork = self._make_fork(GREY_C)
            fork.move_to(LEFT * (5.2 - col * 1.1) + UP * (0.8 - row * 1.2))
            forks_left.add(fork)
        self.play(FadeIn(forks_left), run_time=0.5)

        target_idx = 7
        for i in range(12):
            if i == target_idx:
                check = Text("O", font_size=20, color=GREEN_C, font=F)
                check.move_to(forks_left[i].get_center())
                self.play(forks_left[i].animate.set_color(GREEN_C), FadeIn(check), run_time=0.15)
            else:
                x_mark = Text("X", font_size=20, color=TRAD_COLOR, font=F)
                x_mark.move_to(forks_left[i].get_center())
                self.play(forks_left[i].animate.set_color(TRAD_COLOR), FadeIn(x_mark, scale=0.5), run_time=0.15)

        trad_result = Text("O(n log n): 비교 기반", font_size=20, color=TRAD_COLOR, font=F)
        trad_result.move_to(LEFT * 3.5 + DOWN * 2.8)
        self.play(Write(trad_result), run_time=0.5)

        axol_title = Text("aXOL: 버킷 공명", font_size=24, color=AXOL_GLOW, font=F)
        axol_title.move_to(RIGHT * 3.5 + UP * 2)
        self.play(Write(axol_title), run_time=0.5)

        forks_right = VGroup()
        for i in range(12):
            row, col = i // 4, i % 4
            fork = self._make_fork(GREY_C)
            fork.move_to(RIGHT * (1.8 + col * 1.1) + UP * (0.8 - row * 1.2))
            forks_right.add(fork)
        self.play(FadeIn(forks_right), run_time=0.5)

        wave_text = Text("~", font_size=60, color=AXOL_GLOW, font=F)
        wave_text.move_to(RIGHT * 3.5 + UP * 0)
        ring = Circle(radius=2.5, color=AXOL_GLOW, stroke_width=1, stroke_opacity=0.5)
        ring.move_to(RIGHT * 3.5 + UP * (-0.2))

        self.play(GrowFromCenter(ring), FadeIn(wave_text, scale=2), run_time=0.3)
        self.play(ring.animate.scale(1.5).set_opacity(0), run_time=0.5)

        glow = forks_right[target_idx].copy().set_color(AXOL_GLOW)
        self.play(
            Transform(forks_right[target_idx], glow),
            Flash(forks_right[target_idx].get_center(), color=AXOL_GLOW, flash_radius=0.6, num_lines=8),
            run_time=0.3
        )

        axol_result = Text("O(1): 양자화→위치 배정", font_size=20, color=AXOL_GLOW, font=F)
        axol_result.move_to(RIGHT * 3.5 + DOWN * 2.8)
        self.play(Write(axol_result), run_time=0.5)
        self.wait(2)

    def _make_fork(self, color):
        fork = VGroup(
            Line(DOWN * 0.3, UP * 0.3, color=color, stroke_width=3),
            Line(UP * 0.3 + LEFT * 0.1, UP * 0.3 + RIGHT * 0.1, color=color, stroke_width=3),
            Line(UP * 0.3 + LEFT * 0.1, UP * 0.6 + LEFT * 0.1, color=color, stroke_width=3),
            Line(UP * 0.3 + RIGHT * 0.1, UP * 0.6 + RIGHT * 0.1, color=color, stroke_width=3),
        )
        return fork


class SimilarityReveal(Scene):
    """n=100M Pure O(1) scatter vs std::sort — GPU+CPU 기준 유사도 + 성능 비교"""

    def construct(self):
        self.camera.background_color = BG_COLOR

        # ── JSON에서 모든 데이터 로드 ──
        data = load_data()
        lv = data["large_vis"]
        N_TOTAL = lv["n"]

        # Pre-computed stats from Rust
        exact_match = lv["exact_match_pct"] / 100.0
        kendall_pct = lv["kendall_tau_pct"]
        mean_disp = lv["mean_displacement"]
        within2 = lv["within_2_pct"] / 100.0
        adj_inv = lv["adj_inversions"]
        adj_total = lv["adj_total"]

        # Downsampled arrays (200 points, pre-computed)
        gt_s = lv["gt_downsampled"]
        sc_s = lv["scatter_downsampled"]
        N_BARS = len(gt_s)
        max_val = max(max(gt_s), max(sc_s))

        # Zoom arrays (50 points from middle)
        zoom_gt = lv["zoom_gt"]
        zoom_sc = lv["zoom_scatter"]
        zoom_start = lv["zoom_start_index"]

        # GPU+CPU heterogeneous benchmark for n=100M
        hetero_100m = next((h for h in data["heterogeneous"] if h["n"] == N_TOTAL), None)
        bench_100m = next((b for b in data["benchmarks"] if b["n"] == N_TOTAL), None)

        # n formatting
        n_str = f"{N_TOTAL:,}"

        # ── 장면 1: 타이틀 ──
        title = Text(f"n = {n_str}", font_size=56, color=ACCENT, font=F)
        subtitle = Text("비교 0회, O(1)/원소 — 정말 정렬인가?", font_size=28, color=TEXT_COLOR, font=F)
        VGroup(title, subtitle).arrange(DOWN, buff=0.4)
        self.play(Write(title), run_time=1.0)
        self.play(FadeIn(subtitle, shift=UP), run_time=0.8)
        self.wait(1.5)
        self.play(FadeOut(title), FadeOut(subtitle), run_time=0.5)

        # ── 장면 2: 기존 방식 — std::sort 설명 ──
        std_title = Text("기존 방식: std::sort (CPU)", font_size=32, color=TRAD_COLOR, font=F)
        std_title.to_edge(UP, buff=0.5)
        self.play(Write(std_title), run_time=0.8)

        import math
        n_comparisons = int(N_TOTAL * math.log2(N_TOTAL))
        std_info = VGroup(
            Text("O(n log n) 비교 정렬", font_size=24, color=TEXT_COLOR, font=F),
            Text(f"n = {n_str} -> ~{n_comparisons:,}번 비교", font_size=20, color=GREY_B, font=F),
        ).arrange(DOWN, buff=0.2).next_to(std_title, DOWN, buff=0.4)
        self.play(FadeIn(std_info), run_time=0.8)

        # 바 차트
        BAR_W = 11.0
        BAR_H = 3.2
        bar_w = BAR_W / N_BARS * 0.9
        gap = BAR_W / N_BARS
        x_start = -BAR_W / 2
        y_base = -2.5

        shuffled_indices = list(range(N_BARS))
        random.seed(42)
        random.shuffle(shuffled_indices)
        shuffled_vals = [gt_s[shuffled_indices[i]] for i in range(N_BARS)]

        shuffled_bars = VGroup()
        for i in range(N_BARS):
            h = (shuffled_vals[i] / max_val) * BAR_H
            bar = Rectangle(
                width=bar_w, height=max(h, 0.01),
                color=TRAD_COLOR, fill_opacity=0.5, stroke_width=0,
            ).move_to(RIGHT * (x_start + i * gap + gap / 2) + UP * (y_base + h / 2))
            shuffled_bars.add(bar)

        shuf_label = Text("정렬 전 (무작위)", font_size=18, color=GREY_B, font=F)
        shuf_label.next_to(shuffled_bars, DOWN, buff=0.15)
        self.play(FadeIn(shuffled_bars), FadeIn(shuf_label), run_time=1.0)
        self.wait(0.8)

        sorted_bars = VGroup()
        for i in range(N_BARS):
            h = (gt_s[i] / max_val) * BAR_H
            bar = Rectangle(
                width=bar_w, height=max(h, 0.01),
                color=GREEN_C, fill_opacity=0.6, stroke_width=0,
            ).move_to(RIGHT * (x_start + i * gap + gap / 2) + UP * (y_base + h / 2))
            sorted_bars.add(bar)

        if bench_100m:
            std_ms = bench_100m["std_sort_us"] / 1000.0
        else:
            std_ms = 2500.0
        time_text = Text(f"{std_ms:.0f}ms 소요", font_size=22, color=TRAD_COLOR, font=F)
        time_text.next_to(std_info, DOWN, buff=0.15)

        self.play(
            Transform(shuffled_bars, sorted_bars),
            FadeOut(shuf_label), FadeIn(time_text),
            run_time=2.0,
        )
        self.wait(1.5)
        self.play(
            FadeOut(shuffled_bars), FadeOut(std_title),
            FadeOut(std_info), FadeOut(time_text),
            run_time=0.5,
        )

        # ── 장면 3: aXOL scatter (GPU) — 즉시 결과 ──
        axol_title = Text("aXOL: Pure O(1) scatter (GPU)", font_size=32, color=AXOL_GLOW, font=F)
        axol_title.to_edge(UP, buff=0.5)
        self.play(Write(axol_title), run_time=0.8)

        axol_info = VGroup(
            Text("비교 0회 — 양자화로 위치 배정", font_size=24, color=TEXT_COLOR, font=F),
            Text(f"n = {n_str} -> 0번 비교", font_size=20, color=GREY_B, font=F),
        ).arrange(DOWN, buff=0.2).next_to(axol_title, DOWN, buff=0.4)
        self.play(FadeIn(axol_info), run_time=0.8)

        sc_bars = VGroup()
        for i in range(N_BARS):
            h = (sc_s[i] / max_val) * BAR_H
            bar = Rectangle(
                width=bar_w, height=max(h, 0.01),
                color=AXOL_GLOW, fill_opacity=0.6, stroke_width=0,
            ).move_to(RIGHT * (x_start + i * gap + gap / 2) + UP * (y_base + h / 2))
            sc_bars.add(bar)

        if hetero_100m:
            gpu_scatter_ms = hetero_100m["gpu_scatter_us"] / 1000.0
        else:
            gpu_scatter_ms = 400.0
        axol_time = Text(f"{gpu_scatter_ms:.0f}ms 소요 (GPU)", font_size=22, color=AXOL_GLOW, font=F)
        axol_time.next_to(axol_info, DOWN, buff=0.15)

        self.play(
            FadeIn(sc_bars), FadeIn(axol_time),
            Flash(ORIGIN + UP * 0.5, color=AXOL_GLOW, flash_radius=2, num_lines=12),
            run_time=0.3,
        )
        self.wait(1.0)

        q_text = Text("이게 정렬이 맞을까?", font_size=30, color=ACCENT, font=F)
        q_text.to_edge(DOWN, buff=0.3)
        self.play(Write(q_text), run_time=0.8)
        self.wait(1.5)
        self.play(
            FadeOut(sc_bars), FadeOut(axol_title),
            FadeOut(axol_info), FadeOut(axol_time), FadeOut(q_text),
            run_time=0.5,
        )

        # ── 장면 4: 겹쳐서 비교 ──
        compare_title = Text("겹쳐서 비교", font_size=32, color=TEXT_COLOR, font=F)
        compare_title.to_edge(UP, buff=0.5)

        legend_bar = VGroup(
            VGroup(
                Rectangle(width=0.4, height=0.15, color=GREEN_C, fill_opacity=0.6, stroke_width=0),
                Text("std::sort", font_size=18, color=GREEN_C, font=F),
            ).arrange(RIGHT, buff=0.15),
            VGroup(
                Rectangle(width=0.4, height=0.15, color=AXOL_GLOW, fill_opacity=0.5, stroke_width=0),
                Text("aXOL scatter", font_size=18, color=AXOL_GLOW, font=F),
            ).arrange(RIGHT, buff=0.15),
        ).arrange(RIGHT, buff=0.8).next_to(compare_title, DOWN, buff=0.3)

        gt_bars2 = VGroup()
        sc_bars2 = VGroup()
        y_base2 = -2.8
        BAR_H2 = 3.5
        for i in range(N_BARS):
            h_gt = (gt_s[i] / max_val) * BAR_H2
            h_sc = (sc_s[i] / max_val) * BAR_H2
            bar_gt = Rectangle(
                width=bar_w, height=max(h_gt, 0.01),
                color=GREEN_C, fill_opacity=0.5, stroke_width=0,
            ).move_to(RIGHT * (x_start + i * gap + gap / 2) + UP * (y_base2 + h_gt / 2))
            bar_sc = Rectangle(
                width=bar_w, height=max(h_sc, 0.01),
                color=AXOL_GLOW, fill_opacity=0.4, stroke_width=0,
            ).move_to(RIGHT * (x_start + i * gap + gap / 2) + UP * (y_base2 + h_sc / 2))
            gt_bars2.add(bar_gt)
            sc_bars2.add(bar_sc)

        self.play(Write(compare_title), FadeIn(legend_bar), run_time=0.5)
        self.play(FadeIn(gt_bars2), run_time=0.8)
        self.play(FadeIn(sc_bars2), run_time=0.8)
        self.wait(1.0)

        find_text = Text("차이를 찾을 수 있나요?", font_size=34, color=ACCENT, font=F)
        find_text.to_edge(DOWN, buff=0.3)
        self.play(Write(find_text), run_time=0.8)
        self.wait(2.5)
        self.play(
            FadeOut(gt_bars2), FadeOut(sc_bars2), FadeOut(find_text),
            FadeOut(compare_title), FadeOut(legend_bar),
            run_time=0.5,
        )

        # ── 장면 5: 줌인 ──
        ZOOM_N = len(zoom_gt)
        zoom_label = f"{zoom_start:,} ~ {zoom_start + ZOOM_N:,}"
        zoom_title = Text(f"50개 구간 확대 ({zoom_label})", font_size=24, color=TEXT_COLOR, font=F)
        zoom_title.to_edge(UP, buff=0.5)
        self.play(Write(zoom_title), run_time=0.6)

        zm = max(max(zoom_gt), max(zoom_sc))
        zmn = min(min(zoom_gt), min(zoom_sc))
        z_range = zm - zmn if zm - zmn > 0 else 1

        z_bar_w = 10.0 / ZOOM_N * 0.35
        z_gap = 10.0 / ZOOM_N
        z_x_start = -5.0
        z_y_base = -2.8
        Z_H = 4.0

        gt_zoom_bars = VGroup()
        sc_zoom_bars = VGroup()
        diff_markers = VGroup()
        n_diffs = 0

        for i in range(ZOOM_N):
            x = z_x_start + i * z_gap + z_gap / 2
            h_gt = ((zoom_gt[i] - zmn) / z_range) * Z_H
            h_sc = ((zoom_sc[i] - zmn) / z_range) * Z_H

            bar_gt = Rectangle(
                width=z_bar_w, height=max(h_gt, 0.01),
                color=GREEN_C, fill_opacity=0.6, stroke_width=0,
            ).move_to(RIGHT * (x - z_bar_w * 0.55) + UP * (z_y_base + h_gt / 2))

            bar_sc = Rectangle(
                width=z_bar_w, height=max(h_sc, 0.01),
                color=AXOL_GLOW, fill_opacity=0.6, stroke_width=0,
            ).move_to(RIGHT * (x + z_bar_w * 0.55) + UP * (z_y_base + h_sc / 2))

            gt_zoom_bars.add(bar_gt)
            sc_zoom_bars.add(bar_sc)

            if abs(zoom_gt[i] - zoom_sc[i]) > 1e-9:
                n_diffs += 1
                dot = Dot(
                    point=RIGHT * x + UP * (z_y_base + Z_H + 0.25),
                    radius=0.06, color=TRAD_COLOR,
                )
                diff_markers.add(dot)

        z_legend = VGroup(
            VGroup(
                Rectangle(width=0.25, height=0.12, color=GREEN_C, fill_opacity=0.6, stroke_width=0),
                Text("std::sort", font_size=14, color=GREEN_C, font=F),
            ).arrange(RIGHT, buff=0.08),
            VGroup(
                Rectangle(width=0.25, height=0.12, color=AXOL_GLOW, fill_opacity=0.6, stroke_width=0),
                Text("aXOL", font_size=14, color=AXOL_GLOW, font=F),
            ).arrange(RIGHT, buff=0.08),
            VGroup(
                Dot(radius=0.05, color=TRAD_COLOR),
                Text("차이", font_size=14, color=TRAD_COLOR, font=F),
            ).arrange(RIGHT, buff=0.08),
        ).arrange(RIGHT, buff=0.4).to_edge(DOWN, buff=0.25)

        self.play(FadeIn(gt_zoom_bars), FadeIn(sc_zoom_bars), FadeIn(z_legend), run_time=0.8)
        self.wait(0.5)

        if len(diff_markers) > 0:
            self.play(FadeIn(diff_markers, scale=2), run_time=0.5)
            diff_note = Text(
                f"50개 중 {n_diffs}개만 다름",
                font_size=20, color=TRAD_COLOR, font=F,
            )
            diff_note.next_to(zoom_title, DOWN, buff=0.25)
            self.play(Write(diff_note), run_time=0.6)
            self.wait(2.0)
            self.play(
                FadeOut(gt_zoom_bars), FadeOut(sc_zoom_bars),
                FadeOut(diff_markers), FadeOut(z_legend),
                FadeOut(zoom_title), FadeOut(diff_note),
                run_time=0.5,
            )
        else:
            self.wait(2.0)
            self.play(
                FadeOut(gt_zoom_bars), FadeOut(sc_zoom_bars),
                FadeOut(z_legend), FadeOut(zoom_title),
                run_time=0.5,
            )

        # ── 장면 6: 유사도 지표 ──
        table_title = Text("유사도 지표", font_size=34, color=TEXT_COLOR, font=F)
        table_title.to_edge(UP, buff=0.4)
        n_label = Text(f"n = {n_str}", font_size=20, color=GREY_B, font=F)
        n_label.next_to(table_title, DOWN, buff=0.15)
        self.play(Write(table_title), FadeIn(n_label), run_time=0.6)

        old_header = Text("기존 지표", font_size=22, color=GREY_B, font=F)
        old_metric = Text("위치 정확 일치", font_size=16, color=GREY_B, font=F)
        old_value = Text(f"{exact_match * 100:.1f}%", font_size=52, color=TRAD_COLOR, font=F)
        old_box = VGroup(old_header, old_metric, old_value).arrange(DOWN, buff=0.15)
        old_box.move_to(LEFT * 4.0 + DOWN * 0.5)
        self.play(FadeIn(old_box), run_time=0.8)
        self.wait(0.5)

        new_header = Text("실질 유사도", font_size=22, color=AXOL_GLOW, font=F)
        row1 = VGroup(
            Text("순서 보존", font_size=16, color=GREY_B, font=F),
            Text(f"{kendall_pct:.2f}%", font_size=34, color=AXOL_GLOW, font=F),
        ).arrange(RIGHT, buff=0.3)
        row2 = VGroup(
            Text("평균 이탈", font_size=16, color=GREY_B, font=F),
            Text(f"{mean_disp:.1f}칸", font_size=28, color=AXOL_GLOW, font=F),
        ).arrange(RIGHT, buff=0.3)
        row3 = VGroup(
            Text("2칸 이내", font_size=16, color=GREY_B, font=F),
            Text(f"{within2 * 100:.1f}%", font_size=28, color=GREEN_C, font=F),
        ).arrange(RIGHT, buff=0.3)
        inv_pct = adj_inv / adj_total * 100.0
        row4 = VGroup(
            Text("역전 비율", font_size=16, color=GREY_B, font=F),
            Text(f"{inv_pct:.4f}%", font_size=28, color=AXOL_GLOW, font=F),
        ).arrange(RIGHT, buff=0.3)

        new_box = VGroup(new_header, row1, row2, row3, row4).arrange(DOWN, buff=0.2, aligned_edge=LEFT)
        new_box.move_to(RIGHT * 2.5 + DOWN * 0.5)

        self.play(FadeIn(new_box), run_time=1.5)
        self.wait(1.0)

        arrow = Arrow(
            old_box.get_right() + RIGHT * 0.15,
            new_box.get_left() + LEFT * 0.15,
            color=ACCENT, stroke_width=3,
        )
        reframe = Text("같은 데이터, 다른 질문", font_size=18, color=ACCENT, font=F)
        reframe.next_to(arrow, UP, buff=0.08)
        self.play(GrowArrow(arrow), Write(reframe), run_time=0.8)
        self.wait(2.5)

        self.play(
            FadeOut(old_box), FadeOut(new_box), FadeOut(arrow),
            FadeOut(reframe), FadeOut(table_title), FadeOut(n_label),
            run_time=0.5,
        )

        # ── 장면 7: 성능 비교 (GPU+CPU 이종) ──
        perf_title = Text(f"성능 비교 (n = {n_str}, GPU+CPU)", font_size=28, color=TEXT_COLOR, font=F)
        perf_title.to_edge(UP, buff=0.5)
        hw_note = Text("GPU=500GB/s  CPU=50GB/s  PCIe=25GB/s", font_size=14, color=GREY_D, font=F)
        hw_note.next_to(perf_title, DOWN, buff=0.1)
        self.play(Write(perf_title), FadeIn(hw_note), run_time=0.8)

        if hetero_100m and bench_100m:
            std_us = bench_100m["std_sort_us"]
            gpu_radix_us = hetero_100m["gpu_radix_us"]
            hetero_us = hetero_100m["hetero_total_us"]
            gpu_scatter_us = hetero_100m["gpu_scatter_us"]
        else:
            std_us, gpu_radix_us, hetero_us, gpu_scatter_us = 2500000, 460000, 712000, 400000

        bar_data = [
            ("std::sort\n(CPU)", std_us, TRAD_COLOR, "100%"),
            ("GPU Radix\nSort", gpu_radix_us, GREY_B, "100%"),
            ("aXOL GPU+CPU\nHybrid", hetero_us, AXOL_GLOW, "100%"),
            ("aXOL GPU\nPure O(1)", gpu_scatter_us, AXOL_GLOW,
             f"~{exact_match*100:.0f}%\n(순서 {kendall_pct:.1f}%)"),
        ]
        max_us = max(std_us, gpu_radix_us, hetero_us, gpu_scatter_us)

        perf_bars = VGroup()
        PBAR_W = 5.0
        py_start = 0.8
        py_gap = 1.3

        for idx, (label, us, color, acc) in enumerate(bar_data):
            y = py_start - idx * py_gap
            w = (us / max_us) * PBAR_W
            bar = Rectangle(
                width=max(w, 0.05), height=0.45,
                color=color, fill_opacity=0.7, stroke_width=0,
            )
            bar.move_to(LEFT * (2.5 - w / 2) + UP * y)

            lbl = Text(label, font_size=13, color=color, font=F)
            lbl.next_to(bar, LEFT, buff=0.2)

            if us >= 1_000_000:
                time_str = f"{us/1_000_000:.2f}s"
            else:
                time_str = f"{us/1000:.0f}ms"
            ms_text = Text(time_str, font_size=18, color=TEXT_COLOR, font=F)
            ms_text.next_to(bar, RIGHT, buff=0.15)

            acc_text = Text(acc, font_size=12, color=GREY_B, font=F)
            acc_text.next_to(ms_text, RIGHT, buff=0.12)

            row_group = VGroup(lbl, bar, ms_text, acc_text)
            perf_bars.add(row_group)

        for row_group in perf_bars:
            self.play(FadeIn(row_group), run_time=0.6)

        # Speedup annotation
        if hetero_100m:
            speedup = hetero_100m["hetero_vs_std"]
            sp_text = Text(f"vs std::sort: {speedup:.1f}x", font_size=22, color=ACCENT, font=F)
            sp_text.to_edge(DOWN, buff=0.3)
            self.play(Write(sp_text), run_time=0.6)
            self.wait(2.5)
            self.play(FadeOut(sp_text), run_time=0.3)
        else:
            self.wait(2.5)

        self.play(FadeOut(perf_bars), FadeOut(perf_title), FadeOut(hw_note), run_time=0.5)

        # ── 장면 8: 결론 ──
        c1 = Text("비교 0회  ·  O(1)/원소  ·  GPU+CPU", font_size=26, color=AXOL_GLOW, font=F)
        c2 = Text(f"n = {n_str}", font_size=22, color=GREY_B, font=F)
        c3 = Text(f"위치 일치: {exact_match * 100:.1f}%", font_size=30, color=GREY_B, font=F)
        c4 = Text(f"순서 보존: {kendall_pct:.2f}%", font_size=42, color=AXOL_GLOW, font=F)
        c5 = Text(" ", font_size=10, font=F)
        c6 = Text("\"63%의 정확도\"가 아니라", font_size=24, color=GREY_B, font=F)
        c7 = Text("\"99.99%의 순서 보존\"", font_size=34, color=ACCENT, font=F)

        conclusion = VGroup(c1, c2, c3, c4, c5, c6, c7).arrange(DOWN, buff=0.2)
        conclusion.move_to(UP * 0.3)

        for line in [c1, c2, c3]:
            self.play(Write(line), run_time=0.6)
        self.play(Write(c4), run_time=1.0)
        self.play(
            Flash(c4.get_center(), color=AXOL_GLOW, flash_radius=1.2, num_lines=14),
            run_time=0.4,
        )
        self.wait(0.5)
        self.play(Write(c5), run_time=0.1)
        self.play(Write(c6), run_time=0.8)
        self.play(Write(c7), run_time=1.0)
        self.play(
            Flash(c7.get_center(), color=ACCENT, flash_radius=1.0, num_lines=10),
            run_time=0.4,
        )
        self.wait(3)


class Conclusion(Scene):
    """장면 7: 결론"""

    def construct(self):
        self.camera.background_color = BG_COLOR
        data = load_data()
        best = max(data["benchmarks"], key=lambda b: b["hybrid_speedup"])

        lines = [
            ("기존 패러다임", GREY_B, 32),
            ("비교 정렬: O(n log n)", TRAD_COLOR, 28),
            ("", WHITE, 20),
            ("aXOL 패러다임", AXOL_GLOW, 32),
            ("공명 정렬: O(1)/원소 + 100% 정확", AXOL_GLOW, 28),
        ]

        texts = VGroup()
        for content, color, size in lines:
            if content:
                t = Text(content, font_size=size, color=color, font=F)
            else:
                t = Text(" ", font_size=size, font=F)
            texts.add(t)

        texts.arrange(DOWN, buff=0.4).move_to(UP * 0.5)

        for t in texts:
            self.play(Write(t), run_time=0.8)

        self.wait(1)

        core = Text(
            f"실측 최대 {best['hybrid_speedup']:.1f}x speedup (n={best['n']:,})",
            font_size=36, color=ACCENT, font=F
        )
        core.move_to(DOWN * 2)
        self.play(Write(core), run_time=1.5)

        logo = Text("AXOL", font_size=72, color=AXOL_GLOW, font=F)
        logo.move_to(DOWN * 2)
        self.play(FadeOut(core), run_time=0.5)
        self.play(
            Write(logo),
            Flash(logo.get_center(), color=AXOL_GLOW, flash_radius=2, num_lines=20),
            run_time=1.5
        )
        self.wait(2)
