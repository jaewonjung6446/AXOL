# ============================================================
# AXOL Use Case 4: Waveform Pattern Recognition
# ============================================================
# Task: Classify 8-point waveform samples into signal types
#
# Signal types:
#   0 = sine wave      (smooth oscillation)
#   1 = square wave     (binary high/low)
#   2 = triangle wave   (linear ramp up/down)
#   3 = sawtooth wave   (linear ramp up, sharp drop)
#
# Each sample: 8 consecutive normalized amplitude values [0,1]
# representing one full cycle of the waveform

# === Step 1: Learn from labeled waveform samples ===
# 3 variants of each waveform type (12 total)

learn "waveform" dim=8 quantum=1 seed=42 {
    # --- Sine wave (0): smooth sinusoidal ---
    # Clean sine: sin(2*pi*t/8) mapped to [0,1]
    [0.50, 0.85, 1.00, 0.85, 0.50, 0.15, 0.00, 0.15] = 0
    # Sine with amplitude 0.8
    [0.50, 0.80, 0.93, 0.80, 0.50, 0.20, 0.07, 0.20] = 0
    # Sine with phase shift
    [0.85, 1.00, 0.85, 0.50, 0.15, 0.00, 0.15, 0.50] = 0

    # --- Square wave (1): binary switching ---
    # Clean square
    [0.95, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05] = 1
    # Square with slight ringing
    [0.90, 0.95, 0.95, 0.92, 0.08, 0.05, 0.05, 0.10] = 1
    # Square with 60% duty cycle
    [0.95, 0.95, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05] = 1

    # --- Triangle wave (2): linear ramp ---
    # Clean triangle
    [0.00, 0.25, 0.50, 0.75, 1.00, 0.75, 0.50, 0.25] = 2
    # Triangle with offset
    [0.10, 0.30, 0.55, 0.78, 0.95, 0.72, 0.48, 0.28] = 2
    # Triangle with slight asymmetry
    [0.05, 0.30, 0.55, 0.80, 0.95, 0.70, 0.45, 0.20] = 2

    # --- Sawtooth wave (3): ramp up, sharp drop ---
    # Clean sawtooth
    [0.00, 0.14, 0.28, 0.43, 0.57, 0.71, 0.86, 1.00] = 3
    # Sawtooth with overshoot
    [0.05, 0.18, 0.32, 0.48, 0.60, 0.75, 0.90, 0.95] = 3
    # Sawtooth with noise
    [0.03, 0.17, 0.30, 0.45, 0.55, 0.68, 0.82, 0.97] = 3
}

# === Step 2: Test learned model ===
# Clean sine
observe waveform { x = [0.50, 0.85, 1.00, 0.85, 0.50, 0.15, 0.00, 0.15] }
# Clean square
observe waveform { x = [0.95, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05] }
# Clean triangle
observe waveform { x = [0.00, 0.25, 0.50, 0.75, 1.00, 0.75, 0.50, 0.25] }
# Clean sawtooth
observe waveform { x = [0.00, 0.14, 0.28, 0.43, 0.57, 0.71, 0.86, 1.00] }

# === Step 3: Template matching via basin-based approach ===
define_basins "waveform_templates" {
    dim 8
    basin [0.50, 0.85, 1.00, 0.85, 0.50, 0.15, 0.00, 0.15] volume=0.25
    basin [0.95, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05] volume=0.25
    basin [0.00, 0.25, 0.50, 0.75, 1.00, 0.75, 0.50, 0.25] volume=0.25
    basin [0.00, 0.14, 0.28, 0.43, 0.57, 0.71, 0.86, 1.00] volume=0.25
    fractal_dim 1.6
}

declare "template_matcher" {
    input signal(8)
    relate pattern <- signal via <~>
    output pattern
    quality omega=0.90 phi=0.85
}

weave template_matcher quantum=true seed=42 from_basins="waveform_templates"

# === Step 4: Noisy signals — real-world degraded waveforms ===

# Noisy sine (SNR ~10dB)
observe template_matcher {
    signal = [0.52, 0.80, 0.95, 0.82, 0.48, 0.18, 0.05, 0.20]
}

# Noisy square with heavy ringing
observe template_matcher {
    signal = [0.85, 0.92, 0.90, 0.88, 0.12, 0.08, 0.10, 0.15]
}

# === Step 5: Ambiguous case — sine vs triangle overlap ===
# At certain phases, sine and triangle look very similar
wave ambig_signal = template_matcher {
    signal = [0.10, 0.35, 0.60, 0.82, 0.90, 0.70, 0.42, 0.18]
}

wave sine_template = template_matcher {
    signal = [0.50, 0.85, 1.00, 0.85, 0.50, 0.15, 0.00, 0.15]
}

wave triangle_template = template_matcher {
    signal = [0.00, 0.25, 0.50, 0.75, 1.00, 0.75, 0.50, 0.25]
}

# Constructive interference: template matching
rel sine_match = ambig_signal <-> sine_template via <~>
rel triangle_match = ambig_signal <-> triangle_template via <~>

gaze ambig_signal
observe sine_match {}
observe triangle_match {}

# === Step 6: Resolve disambiguation ===
resolve ambig_signal, sine_template with interfere
resolve ambig_signal, triangle_template with interfere

# Confident observation on ambiguous signal
confident template_matcher max=20 threshold=0.90 {
    signal = [0.10, 0.35, 0.60, 0.82, 0.90, 0.70, 0.42, 0.18]
}
